apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'findbugs'
apply plugin: 'pmd'
apply plugin: 'checkstyle'
apply plugin: 'project-report'
apply plugin: 'maven'
apply plugin: 'build-dashboard'
apply plugin: 'signing'

sourceCompatibility = 1.8
targetCompatibility = 1.8

task wrapper(type: Wrapper) {
    gradleVersion = gradleVersionToUse
}

// General configuration

jar {
    manifest {
        attributes 'Implementation-Title': artifactId, 'Implementation-Version': version
    }
}

repositories {
    mavenCentral()
}

def splitRange(def version) {
	return version.replace(" ","").split(",")
}
def minVersion(def version) {
	def versions = splitRange(version)
	if (versions.length > 1) {
		return versions[0].substring(1)
	}
	return versions[0]
}
def maxVersion(def version) {
	def versions = splitRange(version)
	if (versions.length > 1) {
		return versions[1].substring(0, versions[1].length() - 1)
	}
	return versions[0]
}
def minInclusive(def version) {
	return !version.startsWith("(") && !version.startsWith("]") 
}
def maxInclusive(def version) {
	return !version.endsWith(")") && !version.endsWith("[") 
}
def convertToNumber(def n) {
	try {
		return Integer.parseInt(n)
	} catch (NumberFormatException e) {
		return -1
	}
}
def higherVersion(def v1, def v2) {
	/*
	 * Look at version numbers. If one version is not a number,
	 * then the numbered version has priority (e.g. 2.7 > 2.7-rc0).
	 * If none is a number, fall back to lexicographical comparison.
	 * 2 > 1
	 * 2.0 > 2.0-r1
	 * 2.0-rc2 > 2.0-rc1
	 * A > B
	 * 1.0-rc1 > r02
	 * 1.r02 > 1.0r02
	 * 1.0.0 > 1.0
	 * In case of equality, returns true.
	 */
	 if (v1 == v2) {
	 	return true
	 }
	 def v1parts = v1.split("\\.")
	 def v2parts = v2.split("\\.")
	 for (i in 0..Math.min(v1parts.length, v2parts.length)) {
	 	if (v1parts[i] != v2parts[i]) {
		    def p1 = convertToNumber(v1parts[i])
		    def p2 = convertToNumber(v2parts[i])
		    if (p1 > p2) {
		    	return true
		    }
		    if (p2 > p1) {
		    	return false
		    }
		    /*
		     * They are different Strings, fall back to lexicographical comparison
		     */
		    return v1 >= v2
	 	}
	 }
	 return v1 >= v2
}
def getMaxMin(def v1, def v2) {
	if (higherVersion(minVersion(v1), minVersion(v2))) {
		return [minVersion(v1), minInclusive(v1)]
	}
	return [minVersion(v2), minInclusive(v2)]
}
def getMinMax(def v1, def v2) {
	if(maxVersion(v1).isEmpty()) {
		return [maxVersion(v2), maxInclusive(v2)]
	}
	if(maxVersion(v2).isEmpty()) {
		return [maxVersion(v1), maxInclusive(v1)]
	}
	if (maxVersion(v1) < maxVersion(v2)) {
		return [maxVersion(v1), maxInclusive(v1)]
	}
	return [maxVersion(v2), maxInclusive(v2)]
}
def resolveConflict(def v1, def v2) {
	def maxmin = getMaxMin(v1, v2)
	def minmax = getMinMax(v1, v2)
	if (higherVersion(maxmin[0], minmax[0])) {
		/*
		 * Either there is a single compatible version, or there is a conflict.
		 * In case of conflict, the resolution strategy is to force the minimum
		 * compatible version with the artifact that is most restrictive. The hope
		 * is that the other artifact can work with that version.
		 */
		return maxmin[0]
	}
	return (maxmin[1] ? "[" : "(") + maxmin[0] + ", " + minmax[0] + (minmax[1] ? "]" : "[")
}

configurations.all {
  	resolutionStrategy {
	    /*
	     * This super-fantastic code implements the Holy Grail in Gradle:
	     * it restricts the version ranges transitively.
	     */
	    def substitutions = [
	    	'asm:asm':[Integer.toString(Integer.MAX_VALUE), 'org.ow2.asm:asm', '5.0.+'],
	    	'com.google.guava:guava':["14.0.1",'com.google.guava:guava-jdk5', '14.0.1']
	    	]
	    def depMap = [:]
	    eachDependency {
	    	DependencyResolveDetails details ->
	    		/*
	    		 * Apply substitutions
	    		 */
	    		def req = details.requested
	    		def depId = req.group + ":" + req.name
	    		if (substitutions.containsKey(depId)) {
		    		println depId + " is in the substitution list"
					def conversion = substitutions.get(depId)
					def version = conversion[0]
					def reqversion = maxVersion(req.version)
					if (higherVersion(version, reqversion)) {
			    		println depId + " must be substituted:" + reqversion + " is lower than " + version
						depId = conversion[1]
						version = conversion[2]
						def substitution = depId + ":" + version
						details.useTarget(substitution)
						println "new depId: " + depId
					}
	    		}
	    		if (depMap.containsKey(depId)) {
	    			/*
	    			 * Possible version conflict
	    			 */
	    			def detailsList = depMap.get(depId)
	    			detailsList << details
	    			def previousVersion = detailsList[0].requested.version
	    			def newVersion = req.version
	    			if(!(previousVersion == newVersion)) {
				    	def selectedVersion = resolveConflict(previousVersion, newVersion)
				    	println "transitive dependency resolution: " + depId + " " + previousVersion + " vs. " + newVersion + ". Selected: " + selectedVersion
						detailsList.each { det ->
							det.useVersion(selectedVersion)
						}
	    			}
	    		} else {
	    			depMap.put(depId, [details])
	    		}
	    }
    }
}

configurations {
    doc {
        transitive false
    }
    compile {
        exclude module: 'org.eclipse.xtext.dependencies'
    }
    doclet
}

dependencies {

    compile "commons-io:commons-io:$commonsIOVersion"
    compile "org.apache.commons:commons-math3:$math3Version"
    compile "net.sf.trove4j:trove4j:$trove4jVersion"
    compile "com.google.guava:guava:$guavaVersion"
	compile "org.apache.commons:commons-lang3:$lang3Version"
    compile "org.danilopianini:javalib-java7:$javalib7Version"
    compile "org.danilopianini:javalib:$javalibVersion"
    compile "org.springframework:spring-core:$springVersion"
    compile "org.protelis:protelis.parser:$parserVersion"
    compile "org.slf4j:slf4j-api:$slf4jVersion"
    compile "org.eclipse.emf:org.eclipse.emf.mwe.core:$mweVersion"
    compile "org.eclipse.emf:org.eclipse.emf.mwe.utils:$mweVersion"
	compile "com.google.code.findbugs:findbugs:$findBugsVersion"
	
    testCompile "junit:junit:$junitVersion"

    testRuntime "ch.qos.logback:logback-classic:1.1.3"
    
    doclet "org.jboss.apiviz:apiviz:$apivizVersion"
    
    pmd(
        "net.sourceforge.pmd:pmd-core:$pmdVersion",
        "net.sourceforge.pmd:pmd-vm:$pmdVersion",
        "net.sourceforge.pmd:pmd-plsql:$pmdVersion",
        "net.sourceforge.pmd:pmd-jsp:$pmdVersion",
        "net.sourceforge.pmd:pmd-xml:$pmdVersion",
        "net.sourceforge.pmd:pmd-java:$pmdVersion"
    )
}

// Javadoc Configuration

task aggregateJavadoc(type: Javadoc) {
	source configurations.doc.collect { zipTree(it) }
    source sourceSets.main.allJava
    classpath = sourceSets.main.output + sourceSets.main.compileClasspath
    include '**/*.java'
    destinationDir file("$project.buildDir/docs/javadoc/")
    failOnError = false
    options.showAll()
    options.addBooleanOption('nopackagediagram', true)
	options.addStringOption('Xdoclint:none', '-quiet')
    configure(options) {
        windowTitle "$projectLongName version $project.version Javadoc API"
        docTitle "$projectLongName $project.version reference API"
        links 'http://docs.oracle.com/javase/8/docs/api/'
        links 'http://trove4j.sourceforge.net/javadocs/'
        doclet 'org.jboss.apiviz.APIviz'
        docletpath file(configurations.doclet.asPath)
    }
}

// Artifacts configuration

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: aggregateJavadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

artifacts {
    archives sourcesJar
    archives javadocJar
}

signing {
    sign configurations.archives
}

// Eclipse configuration

eclipse {
	classpath {
    	downloadJavadoc = true
		downloadSources = true
	}
}

// FindBugs configuration

findbugs {
	ignoreFailures = true
	effort = "max"
	reportLevel = "low"
}

tasks.withType(FindBugs) {
	reports {
		xml.enabled = false
		html.enabled = true
	}
}

// PMD configuration

pmd {
	ignoreFailures = true
	ruleSets = []
	ruleSetFiles = files("pmd.xml")
	targetJdk = pmdTargetJdk
	toolVersion = pmdVersion
}

tasks.withType(Pmd) {
	reports {
		xml.enabled = false
		html.enabled = true
	}
}

// Checkstyle configuration

checkstyle {
	ignoreFailures = true
	configFile = new File("style.xml")
}

checkstyleMain << {
    ant.xslt(in: reports.xml.destination,
             style: new File("$project.projectDir/checkstyle-noframes-sorted.xsl"),
             out: new File(reports.xml.destination.parent, 'main.html'))
}

checkstyleTest << {
    ant.xslt(in: reports.xml.destination,
             style: new File("$project.projectDir/checkstyle-noframes-sorted.xsl"),
             out: new File(reports.xml.destination.parent, 'main.html'))
}

// Upload configuration

signArchives.onlyIf { Boolean.parseBoolean(signArchivesIsEnabled) }

uploadArchives {
	repositories {
    	mavenDeployer {
      		beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
      		repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
        		authentication(userName: ossrhUsername, password: ossrhPassword)
      		}
      		snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
        		authentication(userName: ossrhUsername, password: ossrhPassword)
      		}
		    pom.project {
	            name artifactId
	            description projectDescription
	            packaging 'jar'
	            url "$scmRootUrl/$artifactId"
	            licenses {
	                license {
	                    name licenseName
	                    url licenseUrl
	                }
	            }
	            developers {
	            	developer {
	            		name 'Danilo Pianini'
	            		email 'danilo.pianini@unibo.it'
	            		url 'http://danilopianini.apice.unibo.it/'
	            	}
	            	developer {
	            		name 'Jacob Beal'
	            		email 'jakebeal@bbn.com'
	            		url 'http://web.mit.edu/jakebeal/www/'
	            	}
	            }
	            scm {
	            	url "$scmRootUrl/$artifactId"
	            	connection "$scmType:$scmLogin/$scmRepoName"
	            	developerConnection "$scmType:$scmLogin/$scmRepoName"
	            }
		    }
    	}
  	}
}

defaultTasks 'wrapper', 'clean', 'build', 'check', 'assemble', 'install', 'aggregateJavadoc', 'buildDashboard'


