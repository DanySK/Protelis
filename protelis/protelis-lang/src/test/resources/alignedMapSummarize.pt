import protelis:coord:spreading
import protelis:coord:convergecast
import protelis:lang:utils

def myId() {
	self.getDeviceUID().toString()
}

def myValue(field, default) {
	// find my value among the others
	hoodPlusSelf(
		(a, b) -> { if(a.get(0) == myId()) {b} else {a}},
//		(a, b) -> { if(a.get(0) == myId()) {a} else {b}},
		[myId(), NaN],
		field
	).get(1);
}

//def mrSummarize(id, default) {
////	rep(r <- NaN) {
//		let res = alignedMap(
//			nbr([[id, 
//					[
////					"foo",
//						id,
////					"foo" 
//						C(
//							distanceTo(id == myId()), 
////							distanceTo(id == 0),
//							(a,b) -> {a+b}, 
//							env.get("n"), 
//							default
//						)
//					]
//			]]),
//			(key, field) -> { true }, // cond
//			(key, field) -> { myValue(field, default) }, 
////		(key, field) -> { true }, 
////		default
//			[myId(), default]
//		);
//		if(res == []) { default } else { res.get(0).get(1) }
////	}
//}

def mrSummarize(id, default) {
//	rep(r <- NaN) {
		let res = alignedMap(
			nbr([[id, 
					[
//					"foo",
						id,
//					"foo" 
						() -> { C(
							distanceTo(id == myId()), 
//							distanceTo(id == 0),
							(a, b) -> { a + b }, 
							env.get("n"), 
							default
						) }
//						true
					]
			]]),
			(key, field) -> { true }, // cond
			(key, field) -> { 
//				field
				let tField = [field.get(0), field.get(1).apply()];
				myValue(tField, default)
			}, 
//		(key, field) -> { true }, 
//		default
			[id, default]
		);
//		if(res == []) { default } else { res.get(0).get(1) }
//	}
}

def naive(id, default) {
	let n = nbr(self.getDeviceUID().toString());
	let ndv = 	[ n, C(
							distanceTo(myId() == id), 
//							distanceTo(id == 0),
							(a, b) -> { a + b }, 
							env.get("n"), 
							default
						)
				];
	myValue(ndv, default)
}
naive(myId(), 0)
//mrSummarize(myId(), 0)
//mrSummarize(true, 0)