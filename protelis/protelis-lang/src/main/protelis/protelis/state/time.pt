module protelis:state:time
import java.lang.Math.min
import java.lang.Math.max
import protelis:lang:utils

/**
 * @param event bool, event
 * @return 		bool, true if the event is always verified
 */
public def allTime(event) {
	rep(t <- event) {
		t && event
	}
}

/**
 * @param event bool, event
 * @return 		bool, whether the event has occurred at least once
 */
public def anyTime(event) {
	rep(t <- event) {
		t || event
	}
}

/**
 * Apply a function while condition is true.
 * 
 * @param event bool, event
 * @param f 	() -> T, function to be applied
 * @param null  T, null value
 * @return 		T, apply f if event occurs, return null otherwise
 */
public def applyWhile(event, f, null) {
	if(event) { f.apply() } else { null }
}

/**
 * @param length num, count down length
 * @return 		 num, remaining time
 */
public def countDown(length) {
	countDownWithDecay(length, self.dt())
}

/**
 * 
 * @param length num, count down length
 * @param dt	 num, decay
 * @return 		 num, remaining time
 */
public def countDownWithDecay(length, dt) {
	T(length, 0, (t) -> {t - dt})
}

/**
 * Counter.
 * 
 * @param start num, counter initial value
 * @param inc 	num, how much to increase the counter
 * @return 		num, current status of the counter
 */
public def counter(start, inc) {
	rep(c <- start) {
		c + inc
	}
}

/**
 * How many times an event occurred.
 * 
 * @param event bool, event to be monitored
 * @return 		num, how many times an event occurred
 */
public def countTrue(event) {
	rep(c <- 0) {
		c + if(event) { 1 } else { 0 }
	}
}

/**
 * Cyclic timer.
 * 
 * @param length num, timeout
 * @return 		 bool, true if the timeout is expired, false otherwise
 */
public def cyclicTimer(length) {
	cyclicTimerWithDecay(length, self.dt())
}

/**
 * Cyclic timer.
 * 
 * @param length num, timeout
 * @param decay  num, decay rate
 * @return 		 bool, true if the timeout is expired, false otherwise
 */
public def cyclicTimerWithDecay(length, decay) {
	rep(left <- length) {
		if(left == 0) {
			length
		} else {
			countDownWithDecay(length, decay)
		}
	} == length
}

/**
 * Periodically invoke a function.
 * 
 * @param length num, timeout
 * @param f 	 () -> T, function to be invoked
 * @param null 	 T, default value
 * @return 		 T, apply f if the timeout is expired, null otherwise
 */
public def cyclicFunction(length, f, null) {
	cyclicFunctionWithDecay(length, self.dt(), f, null)
}

/**
 * Periodically invoke a function.
 * 
 * @param length num, timeout
 * @param decay  num, decay rate
 * @param f 	 () -> T, function to be invoked
 * @param null 	 T, default value
 * @return 		 T, apply f if the timeout is expired, null otherwise
 */
public def cyclicFunctionWithDecay(length, decay, f, null) {
	if (cyclicTimerWithDecay(length, decay)) {
		f.apply()
	} else {
		null
	}
}

/**
 * 
 * @param signal num, signal to be monitored
 * @return 		 num, variation between current and old values
 */ 
public def delta(signal) {
	rep(old <- [signal, 0]) {
		[signal, signal - old.get(0)]
	}.get(1)
}

/**
 * Exponential back-off filter.
 * 
 * @param signal num, signal to be filtered
 * @param a 	 num, alpha value
 * @return 		 num, filtered signal
 */
public def ebfFilter(signal, a) {
	rep(old <- signal) {
		signal * a + old * (1 - a)
	}
}

/**
 * Flip two values at each round. Return b at first.
 *
 * @param a T, first value
 * @param b T, second value
 * @return  T, (ba)+ sequence of values
 */ 
public def flip(a, b) {
	rep(c <- a) {
		(a + b) - c
	}
}

/**
 * @param signal T, signal to be monitored
 * @param time 	 num, consider the signal stable after this time
 * @return 		 bool, true if the signal value does not change for at least time
 */
public def isSignalStable(signal, time) {
	let t = 
		rep(old <- [signal, 0]) {
			mux(signal == old.get(0)) { 
				[signal, old.get(1) + self.dt()]
			} else { 
				[signal, 0]
			}
		}.get(1);
	t >= time
}

/**
 * @param event   bool, event
 * @param timeout num, timeout
 * @return 		  bool, true if the event occurred before timeout, false otherwise
 */
public def isRecentEvent(event, timeout) {
	if(event) { 
		true
	} else { 
		countDown(timeout) > 0
	}
}

/**
 * @param signal bool, binary signal to be monitored
 * @return 		 bool, true if the signal had a rising edge, false otherwise
 */
public def isRisingEdge(signal) {
	rep(old <- [signal, false]) {
		mux(!old.get(0) && signal) { 
			[signal, true]
		} else { 
			[signal, false]
		}
	}.get(1);
}

/**
 * Hold value until a specified timeout. 
 * 
 * @param value   T, value to be stored
 * @param null    T, default value
 * @param timeout num, hold the value for this amount of time
 * @param dt 	  num, increase the time of this value
 * @return 		  T, hold value if timeout is not expired, null otherwise
 */
public def limitedMemory(value, null, timeout, dt) {
	if(wait(timeout)) { null } else { value }
}

/*
 * Timer.
 * 
 * @param initial num, initial value of the timer
 * @param zero num, lower bound of the timer
 * @param decay (num) -> num, decay rate
 * @return current status of the timer
 * @see countDown
 */
public def T(initial, zero, decay) {
	rep(v <- initial) { 
		// rep is initialized only during the first invocation
		min(initial, max(zero, decay.apply(v)))
	}
}

/**
 * @param value T, signal
 * @return 		T, the same signal
 */
public def Tfilter(value) {
	T(value, value, identity)
}

/**
 * Time flow.
 * 
 * @return num, time since the first tick
 */
public def tick() {
	counter(0, self.dt())
}

/**
 * 
 * @param timeout num, timeout
 * @return 		  bool, true after timeout, false otherwise
 */
public def trueOnceAfter(timeout) {
	countDown(timeout) <= 0
}

/**
 * @param timeout num, timeout
 * @return 		  bool, true once every timeout, false otherwise
 */
public def trueOnceEvery(timeout) {
	cyclicTimer(timeout)
}

/**
 * @param timeout num, timeout
 * @param event   bool, event
 * @return 		  bool, true if the event occurred within last time period
 */
public def trueDuringLast(timeout, event) {
	if(event) { true } else { tick() <= timeout }
}

/**
 * @param timeout num, timeout
 * @param event   bool, event
 * @return        bool, true if a true condition has persisted for time
 */
public def trueFor(time, event) {
	if(event) { tick() >= time } else { false }
}

/**
 * 
 * @param signal T, value to be monitored
 * @return 		 bool, whether v has changed given its previous state
 */
public def valueChanged(signal) {
	rep(old <- [signal, true]) {
		[signal, if(signal == old) { false } else { true }]
	}.get(1)
}

/**
 * SAMEAS valueChanged
 * Track when the region has changed, so that stale state can be discarded.
 * 
 * @param region bool, region discriminant
 * @return       bool, true if the region has changed, false otherwise
 * @see valueChanged
 */
public def regionChanged(region) {
	rep(old <- [region, 0]) {
		[region, 
			mux(region == old.get(0) && (old.get(1) == 0 || old.get(1) > 2)) {
					0
			} else {
				old.get(1) + 1
			}
		]
	}.get(1) > 0
}

/**
 * @param timeout num, count down length
 * @return 		  bool, whether the countdown is expired
 */
public def wait(timeout) {
	countDown(timeout) <= 0
}

/**
 * @param timeout num, timeut
 * @param f 	  () -> T, function to be applied
 * @param null    T, null value
 * @return 		  T, apply f after x, null otherwise
 */
public def waitAndApply(timeout, f, null) {
	if(wait(timeout)) { f.apply() } else { null }
}