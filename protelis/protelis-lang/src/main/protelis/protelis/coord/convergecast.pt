module protelis:coord:convergecast
import protelis:coord:spreading
import protelis:state:time
import protelis:lang:utils 

/**
 * Estimate and broadcast the average value within a spatial region.
 * 
 * Return type: (bool, num) -> num.
 * @param sink whether the device is the root of the spanning tree
 * @param local local value
 * @return average value
 */
public def average(sink, value) {
	summarize(sink, sum, value, 0) / neighborhood()
}

/**
 * Estimate the average value across a bounded spatial region.
 * 
 * Return type: (bool, num) -> num.
 * @param sink whether the device is the root of the spanning tree
 * @param local local value
 * @param range region range
 * @param null default value
 * @return average value
 */
public def boundAverage(sink, local, range, null) {
	boundSpreadingWithRange(
		() -> { closerThan(sink, range) }, 
		() -> { average(sink, local) }, 
		null
	)
}

/*
 * Aggregate a field within a spanning tree built according to the maximum
 * decrease in potential. Concentrate the potential estimated according to 
 * the given HoodOp function.
 * 
 * Return type: (num, fun, any, any) -> any
 * @param potential direction of the aggregation
 * @param reduce HoodOp function
 * @param local local value 
 * @param null expression evaluated when the field is empty
 * @return aggregated value
 */
public def C(potential, reduce, local, null) {
	rep (v <- local) {
		reduce.apply(local,
			/*
			 * TODO: switch to accumulateHood
			 */
			hood(
			    // HoodOp
				(a, b) -> { reduce.apply(a, b) },
				// expression that will be evaluated if the field is empty
				null,
				// argument to evaluate (must return a Field)
				mux (nbr(findParent(potential, identity)) == self) { nbr(v) } else { null }
			)
		)
	}	
}

/**
 * The potential-source converges to the sum of other device values.
 * C  collects  values  over  a  spanning  tree.  Even  small  perturbations
 * can  cause  loss  or  duplication  of  values  with
 * major transient impact on its result. When the accumulation
 * operation for C is either idempotent (e.g., logical and, or)
 * or  separable  (e.g.,  summation),  this  can  be  mitigated  by
 * using all paths down the potential function rather than just
 * one. Can implement  any  other  idempotent  or  separable  function.
 * 
 * Return type: (num, num) -> num.
 * @param potential sum values descending this potential
 * @param local value
 * @return aggregated value
 */
public def cMultiSum(potential, local) {
	 hoodWstateful(local, sum, 0, (v) -> {  				
	 	mux (potential >= nbr(potential)) { 
 				0
		} else {
			nbr(v / sumHood(
				mux (nbr(potential) < potential) { nbr(local) } else { 0 }
			))
		} 
	})
}

/**
 * The potential-source converges to the min of other device values.
 * 
 * Return type: (num, num) -> num.
 * @param potential minimize values descending this potential
 * @param local value
 * @return minimum value
 */
public def cMultiMin(potential, local) {
	 hoodWstateful(local, min, Infinity, (v) -> { 
	 	mux (potential < nbr(potential)) { nbr(v) } else { Infinity }
	 })
}

/**
 * The potential-source converges to the max of other device values.
 * 
 * Return type: (num, num) -> num.
 * @param potential minimize values descending this potential
 * @param local value
 * @return maximum value
 */
public def cMultiMax(potential, local) {
	 -cMultiMin(potential, -local)
}

/**
 * Devices agree on a common value.
 * 
 * Return type: (num, f) -> num.
 * @param init initial device value 
 * @param f how to determine consensus
 * @return shared value
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Gossip a value manipulated according to f.
 * 
 * Return type: (bool, any, fun) -> any.
 * @param sink whether the device is the root of the spanning tree
 * @param value what to gossip
 * @param f how to manipulate value
 * @return the value resulting from gossip
 */
public def cossip(sink, value, f) {
	summarize(sink, f, value, value)	
}

/**
 * Estimate the diameter of the connected component joined by the current
 * device.
 * 
 * Return type: (bool) -> num.
 * @param source source of the connected component
 * @return diameter of the connected component
 */
public def diameter(source) {
	let d = distanceTo(source);
	2 * rep (maxd <- 0) {
		max(if (d < Infinity) { d } else { 0 }, maxHood(nbr(maxd)))
	}
}

/**
 * Find the parent of the current node following the maximum decrease in 
 * potential.
 * 
 * Return type: (num, fun) -> any.
 * @param potential potential
 * @param accumulate what to do with the parent
 * @return -2 root, -1 no parent, accumulate(parent) otherwise
 */
public def findParent(potential, accumulate) {
	mux (minHood(nbr(potential)) < potential) {
		let closest = minHood(nbr([potential, accumulate.apply(self)]));
		if (closest.size() > 1) { closest.get(1) } else { noParent() }
	} else { imRoot() }
}

/**
 * @return error while finding parent
 */
def noParent() { -1 }

/**
 * @return "I've no parent" value
 */
def imRoot() { -2 }

/**
 * Find the parent ID of the current node following the maximum decrease in 
 * potential.
 * 
 * Return type: (num, fun) -> num.
 * @param potential potential
 * @param accumulate what to do with the parent
 * @return parent id
 */
public def findParentId(potential) {
	findParent(potential, (node) -> { node.getDeviceUID() })
}
 
/**
 * Laplacian consensus.
 * 
 * Return type: (num, num) -> num.
 * @param init initial value
 * @param epsilon epsilon
 * @return value agreed upon consensus
 */
public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
}

/**
 * Aggregate the feedbacks in a region.
 * 
 * Return type: (bool, num) -> num.
 * @param sink whether the device is the root of the spanning tree
 * @param feedback value to be aggregated
 * @return sum of feedbacks
 */
public def opinionFeedback(sink, feedback) {
	Tfilter(C(distanceTo(sink), (a,b) -> { a + b }, feedback, 0))
}
 
/**
 * Broadcast the value accumulated by the source. Example: 
 * 'summarize(distanceTo(sink), sum, 1, 0)' broadcast the sum number of 
 * devices in a region.
 * 
 * Return type: (bool, fun, num, num) -> num.
 * @param sink whether the device should collect the aggregated information
 * @param accumulate how to aggregate
 * @param local local value
 * @param null default value
 * @return aggregated value according to accumulate 
 */
public def summarize(sink, accumulate, local, null) {
	broadcast(sink, C(distanceTo(sink), accumulate, local, null))
}
 