module protelis:coord:meta
import protelis:lang:utils
import protelis:coord:accumulation
import protelis:coord:spreading

/**
 * Splice devices into regions according to the discriminant and apply f.
 *
 * @param discriminant T, split regions according to this value
 * @param filter       (T) -> bool, how to handle the discriminant value
 * @param function     () -> T', what to apply in each region
 * @param default      T', default value
 * @return             T', apply f or default
 */
public def computeMultiRegion(discriminant, filter, function, default) {
    if (filter.apply(discriminant)) {
        let res = alignedMap(
            nbr([[discriminant, default]]),
            (key, field) -> { filter.apply(key) },
            (key, field) -> { function.apply() },
            default
        );
        if (res == []) { default } else { res.get(0).get(1) }
    } else { default }
}

/**
 * Feed f with pre-processed data, and then post-process the output.
 *
 * @param input G, input
 * @param pre  (G) -> H, how to pre-process
 * @param f    (H) -> I, what to do
 * @param post (I) -> T, how to post process
 * @return      T, post(f(pre(input)))
 */
public def processAndApply(input, pre, f, post) {
    post.apply(f.apply(pre.apply(input)))
}

/**
 * Feed f with pre-processed data.
 *
 * @param input G, input
 * @param pre  (G) -> H, how to pre-process
 * @param f    (H) -> I, what to do
 * @return      I, f(pre(input))
 */
public def preProcessAndApply(input, pre, f) {
    f.apply(pre.apply(input))
}

/**
 * Apply f, and then post-process the output.
 *
 * @param input G, input
 * @param f    (H) -> I, what to do
 * @param post (I) -> T, how to post process
 * @return      T, post(f(input))
 */
public def postProcessAndApply(input, f, post) {
    post.apply(f.apply(input))
}

/**
 * Publish/Subscribe pattern.
 * 
 * @param publisher   bool, who publish
 * @param subscriber  bool, who is subscribing
 * @param information T, what to share
 * @param null        T, what to share if you are neither a subscriber nor a
 *                    publisher
 * @return            T, information if the device is a publisher, a
 *                    subscriber or is in the shortest path between them.
 *                    null otherwise
 */
public def publishSubscribe(publisher, subscriber, information, null) {
      if (C(distanceTo(publisher), or, subscriber, false)) {
          broadcast(publisher, information)
      } else {
          null
      }
}