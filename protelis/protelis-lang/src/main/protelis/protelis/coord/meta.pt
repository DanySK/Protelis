module protelis:coord:meta
import protelis:lang:utils

/**
 * Splice devices into regions according to the discriminant and apply f.
 * 
 * @param discriminant T, split regions according to this value
 * @param filter        (T) -> bool, how to handle the discriminant value
 * @param function        () -> T', what to apply in each region
 * @param default        T', default value
 * @return                T', apply f or default
 */
public def computeMultiRegion(discriminant, filter, function, default) {
    if (filter.apply(discriminant)) {
        let res = alignedMap(
            nbr([[discriminant, default]]),
            (key, field) -> { filter.apply(key) },
            (key, field) -> { function.apply() }, 
            default
        );
        if (res == []) { default } else { res.get(0).get(1) }
    } else { default }
}

/**
 * Feed f with pre-processed data, and then post-process the output.
 * 
 * @param input G, input
 * @param pre  (G) -> H, how to pre-process
 * @param f    (H) -> I, what to do
 * @param post (I) -> T, how to post process
 * @return         T, post(f(pre(input)))
 */
public def processAndApply(input, pre, f, post) {
    post.apply(f.apply(pre.apply(input)))
}

/**
 * Feed f with pre-processed data.
 * 
 * @param input G, input
 * @param pre  (G) -> H, how to pre-process
 * @param f    (H) -> I, what to do
 * @return      I, f(pre(input))
 */
public def preProcessAndApply(input, pre, f) {
    f.apply(pre.apply(input))
}

/**
 * Apply f, and then post-process the output.
 * 
 * @param input G, input
 * @param f    (H) -> I, what to do
 * @param post (I) -> T, how to post process
 * @return      T, post(f(input))
 */
public def postProcessAndApply(input, f, post) {
    post.apply(f.apply(input))
}