module protelis:coord:graph
import protelis:lang:utils
import protelis:coord:nonselfstabilizing:accumulation

public def checkLeaf(myId, inbound) {
	rep (v <- inbound) {
		unionHood(nbr(v))
	}.intersection([myId]).size() == 0
}

public def checkRoot(inbound) {
	inbound == []
}

public def checkChain(myId, inbound) {
	chain(myId, inbound).intersection([myId]).size() > 0 || checkSelfChain(myId, inbound)
}

public def checkSelfChain(myId, inbound) {
	inbound.intersection([myId]).size() > 0
}

public def chain(myId, inbound) {
	mux (inbound != []) {
		rep (v <- inbound) {
			v.union(
				hood(
					(a, b) -> { a.union(b) }, 
					[], 
//					mux (isParent(myId, v)) { nbr(inbound) } else { [] }
					nbrParent(myId, v, inbound, [])
				)
			)
		}
	} else { [] }
}

public def isParent(myId, inbound) {
	inbound.intersection(nbr([myId])).size() > 0
}

public def nbrParent(myId, inbound, message, null) {
	let res = mux (isParent(myId, inbound)) { nbr(message) } else { null };
	mux (res == []) { null } else { res }
}

def spreadGLB(myId, inbound, nodes) {
	rep (v <- [[-Infinity], -Infinity]) {
		mux (isNotEmpty(intersection(nodes, [myId]))) { [[myId], 0] } 
		else {
			let aggr = hood(
				(a, b) -> {
					let c = intersection(nodes, a.get(0));
					if (isEmpty(c)) { 
						[intersection(nodes, b.get(0)), b.get(1)]
					} else {
						if (c.size() == nodes.size()) { a } 
							else { 
							if (isNotEmpty(intersection(nodes, b.get(0)))) {
								[c.union(b.get(0)), max(a.get(1), b.get(1))]
							} else { [c, a.get(1)] }
						}
					}
				}, [], nbrParent(myId, inbound, v, [[-Infinity], -Infinity])
			);
			if (aggr == []) { [[-Infinity], -Infinity] } 
			else { [aggr.get(0), aggr.get(1) + 1] }
		}	
	}
}

public def greatestLowerBound(myId, inbound, nodes) {
//	spreadGLB(myId, inbound, nodes)
	let spread = spreadGLB(myId, inbound, nodes);
	let v =
		if (spread.get(0).size() == nodes.size()) { spread.get(1) } 
		else { Infinity };
	gossip(v, min) == v
}

def intersection(list1, list2) {
	list1.intersection(list2)
}

def isEmpty(list) {
	list.size() == 0
}

def isNotEmpty(list) {
	list.size() > 0
}