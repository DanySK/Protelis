module protelis:coord:tree
import protelis:coord:accumulation
import protelis:coord:spreading
import protelis:lang:utils

/**
 * Build a spanning tree.
 * 
 * @param potential num,  potential to be followed
 * @return			ExecutionContext, parent
 */
public def spanningTree(potential) {
	spanningTreeExtended(potential, identity, self)
}

/**
 * Build a spanning tree.
 * 
 * @param potential num, potential to be followed
 * @param function  (T) -> T', function to be applied to the parent value
 * @param init 		T', initial value of the device
 * @return 			[num|ExecutionContext, T']
 */
public def spanningTreeExtended(potential, function, init) {
	rep (parent <- [imRoot(), init]) {
		findParentExtended(
			potential, 
			identity, 
			(value) -> { function.apply(value) }, 
			parent.get(1)
		)
	}
}

/**
 * Apply function to the children of the current device.
 * 
 * @param potential num, potential to be followed
 * @param function  (T) -> T, function to be applied to the children value
 * @param default   T, default value for devices which are not children
 * @return 			[child, T]
 */
public def getChildren(potential, function, default) {
	mux (nbr(findParent(potential, identity)) == self) { 
		nbr([self, function.apply()])
	} else {
		[noParent(), default]
	}
}

/**
 * Assuming to have a spanning tree, apply f where condition holds,
 * g otherwise.
 * 
 * @param tree 		() -> T, tree
 * @param condition bool, condition
 * @param f 		(T) -> T', what to do if condition is true
 * @param g			(T) -> T', what to do if condition is false
 * @return 			T', apply f where condition holds, g otherwise
 */
public def applyOnTree(tree, condition, f, g) {
	let parent = tree.apply();
	mux (condition) { 
		f.apply(parent)
	} else {
		g.apply(parent)
	}
}

/**
 * Assuming to have a spanning tree, apply f to the children of the first 
 * device where condition holds, g otherwise.
 * 
 * @param tree 	 () -> [ExecutionContext, bool], tree
 * @param filter (bool) -> bool, whether to execute f or g according to the parent condition
 * @param f 	 ([ExecutionContext, bool]) -> T', what to do if condition is true
 * @param g		 ([ExecutionContext, bool]) -> T', what to do if condition is false
 * @return 		 T', apply f where condition holds, g otherwise
 */
public def descendBranch(parent, filter, f, g) {
	let p = parent.apply(); // [ self, something(parent) ]
	mux (filter.apply(p.get(1))) { 
		f.apply(p)
	} else {
		g.apply(p)
	}
}

/**
 * Assuming to have a spanning tree, apply f to the children of the first 
 * device where condition holds, g otherwise.
 * 
 * @param potential num, potential
 * @param filter    (bool) -> bool, whether to execute f or g according to the parent condition
 * @param f 	 	([ExecutionContext, bool]) -> T', what to do if condition is true
 * @param g		 	([ExecutionContext, bool]) -> T', what to do if condition is false
 * @return 		 	T', apply f where condition holds, g otherwise
 */
public def descendBranch2(potential, filter, f, g) {
	descendBranchWithNull(potential, 0, filter, f, g)
}

/**
 * Assuming to have a spanning tree, apply f to the children of the first 
 * device where condition holds, g otherwise.
 * 
 * @param potential num, potential
 * @param null	 	num, null potential value
 * @param filter 	(bool) -> bool, whether to execute f or g according to the parent condition
 * @param f 	 	([ExecutionContext, bool]) -> T', what to do if condition is true
 * @param g		 	([ExecutionContext, bool]) -> T', what to do if condition is false
 * @return 		 	T', apply f where condition holds, g otherwise
 */
public def descendBranchWithNull(potential, null, filter, f, g) {
	let c = forecastObstacleWithMetric(
		potential == null, 
		filter.apply(), 
		() -> { potential }
	);
	mux (c) { 
		f.apply([findParent(potential, identity), c])
	} else { 
		g.apply([findParent(potential, identity), c])
	}
}

/**
 * Assuming to have a spanning tree, apply f to the father of any of the
 * devices where condition holds, g otherwise.
 * 
 * @param potential num, potential
 * @param filter 	(bool) -> bool, whether to execute f or g according to the parent condition
 * @param f 	 	([ExecutionContext, bool]) -> T', what to do if condition is true
 * @param g		 	([ExecutionContext, bool]) -> T', what to do if condition is false
 * @return 		 	T', apply f where condition holds, g otherwise
 */
public def ascendBranch(potential, filter, f, g) {
	if (C(potential, or, filter.apply(), filter.apply())) {
		f.apply(getChildren(potential, filter, false))
	} else {
		g.apply()
	}
}