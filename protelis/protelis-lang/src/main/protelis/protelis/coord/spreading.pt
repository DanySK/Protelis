module protelis:coord:spreading
import org.apache.commons.math3.util.FastMath.floor
import protelis:lang:utils
import protelis:state:time

/**
 * Euclidean metric
 */
public def crfGradient(src, initial, metric, accumulate, latency, range) {
	// potential <- [distance, speed, accumulatedValue]
	rep(potential <- [Infinity, 0, initial]) {
		mux(src) {
			[0, 0, initial]
		} else {
			let ndv = nbr(potential);
			let d = ndv.get(0); // inf
			let v = ndv.get(1); // 0
			let dt = self.dt(); // 1
			let nrange = metric.apply(); // 1
			mux(anyHood((d + nrange + v * (latency.apply() + dt)) < potential.get(0))) {
				minHood([d + nrange, 0, accumulate.apply(ndv.get(2))])
			} else {
				let v0 = if(dt == 0) { 1 } else { range / (dt * 12) };
				[potential.get(0) + v0 * dt, v0, potential.get(2)]				
			}
		}
	}.get(2)
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num) -> num.
 * @param v distance to add
 * @return field of distances from the current to its neighbors
 */
public def addRange(v) {
	addRangeWithMetric(v, nbrRange)
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num, fun) -> num.
 * @param v distance to add
 * @param next continuation
 * @return field of distances from the current to its neighbors
 */
public def addRangeWithContinuation(v, next) {
	next.apply(addRangeWithMetric(v, nbrRange))
}

/*
 * Add of 1 the field of distances of the current node's neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current to its neighbors
 */
public def addRangeHop() {
	addRangeWithMetric(1, nbrRangeHop)
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num, f) -> num.
 * @param v distance to add
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return field of distances from the current to its neighbors
 */
public def addRangeWithMetric(v, metric) {
	v + metric.apply()
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num, fun, num, f) -> num.
 * @param v distance to add
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @param speed communication speed
 * @param latency communication latencies between neighbors 
 * @return field of distances from the current to its neighbors
 */
public def addRangeWithLag(v, metric, speed, latency) {
	addRangeWithMetric(v, metric) + speed * (latency.apply() + self.dt())
}

/**
 * Constrain the spreading of f only across a region. 
 * 
 * Return type: (bool, fun, any) -> any. f return type and null should be
 * type consistent.
 * @param region whether the function is spreaded or not
 * @param f function to be spreaded
 * @param null default value return whether f is not spreaded
 * @return apply f inside the region, return null otherwise
 */
public def boundSpreading(region, f, null) {
	if (region) {
		f.apply()
	} else {
		null
	}
}

 /**
 * Constrain the spreading of f only within devices close to the source. 
 * 
 * Return type: (bool, num, fun, any) -> any. f return type and null should be
 * type consistent.
 * @param region whether the function is spreaded or not
 * @param range maximum spreading distance from the source
 * @param f function to be spreaded
 * @param null default value return whether f is not spreaded
 * @return apply f inside the region, return null otherwise
 */
public def boundSpreadingWithinRange(source, range, f, null) {
	boundSpreading(distanceTo(source) < range, f, null);
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current node is a source
 * @param value what to broadcast
 * @return broadcasted value
 */
public def broadcast(source, value) {
	broadcastWithMetric(source, value, nbrRange)
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current node is a source
 * @param value what to broadcast
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return broadcasted value
 */
public def broadcastWithMetric(source, value, metric) {
	G(source, value, metric, identity)
}

/**
 * Constrain the spreading of broadcast function only across a region. 
 * 
 * Return type: (bool, any) -> any. broadcast return type and null should be
 * type consistent.
 * @param region whether the function is spreaded or not
 * @param null default value return whether f is not spreaded
 * @return broadcast inside the region, return null otherwise
 */
public def boundBroadcast(region, null) {
	boundSpreading(region, broadcast, null)
}

/**
 * Dynamically computes distributed routes between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. Examples 
 * of its use include long-range reliable communications, or advanced crowd 
 * steering applications in pervasive computing. The “channel” is a Boolean 
 * field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * @param source whether the device is a source
 * @param destination whether the device is a destination
 * @param obstacle whether the device is an obstacle
 * @param thr threshold for Double comparison
 * @param width how much to dilate the channel
 * @return true if the device is on the shortest path, false otherwise
 */
public def channel(source, destination, obstacle, thr, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		let d = distanceBetween(source, destination);
  		if (d == Infinity) { false }
  		else {
  			distanceTo(distanceTo(source) + distanceTo(destination) <=  d + thr) <= width
  		}
  	} 
}

/**
 * Channel pattern.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * @param source whether the device is a source
 * @param destination whether the device is a destination
 * @param obstacle whether the device is an obstacle
 * @param width how much to dilate the channel
 * @return true if the device is on the shortest path, false otherwise
 */
public def channel2(source, destination, obstacle, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		distanceTo(shortestPath(source, destination)) <= width
  	} 
}

/**
 * Dilate a spatial region.
 * 
 * Return type: (bool, num) -> bool.
 * @param region whether the device is inside the region
 * @param width how big the dilatation is
 * @return dilated region
 */
 public def dilate(region, width) {
 	distanceTo(region) < width	
 }
 
/**
 * Smallest distance between source and destination nodes.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current node is a source
 * @param destination whether the current node is a destination
 * @return smallest distance between source and destination nodes
 */
public def distanceBetween(source, dest) { 
	distanceBetweenWithMetric(source, dest, nbrRange)
}

/**
 * Smallest distance between source and destination nodes.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current node is a source
 * @param destination whether the current node is a destination
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return smallest distance between source and destination nodes
 */
public def distanceBetweenWithMetric(source, dest, metric) { 
	G(source, distanceToWithMetric(dest, metric), metric, identity)
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool) -> num.
 * @param source whether the current node is a source
 * @return distance to the closest source
 */
public def distanceTo(source) {
	distanceToWithMetric(source, nbrRange)	
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool, f) -> num.
 * @param source whether the node is a source
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return field of minimum distances to the closest source
 */
public def distanceToWithMetric(source, metric) {
	G(source, 0, metric, (v) -> {v + metric.apply()})
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool, bool) -> num.
 * @param source whether the node is a source
 * @param obstacle whether the node is an obstacle
 * @return field of minimum distances to the closest source
 */
public def distanceToWithObstacle(source, obstacle) {
	if (obstacle) { Infinity }
	else { distanceTo(source) }
}

/*
 * Propagate values across a spanning tree starting from the closest source.
 * 
 * Return type: (bool, any, fun, fun) -> any. initial and accumulate parameter
 * type must be consistent.
 * 
 * @param source whether the current node is a source
 * @param initial initial value of the computation
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @param accumulate how to manage the value
 * @return accumulated value
 */
public def G(source, initial, metric, accumulate) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			// If the node is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other node potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			// TODO do we need a default?
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
			])
		}
	}.get(1) // return the accumulated value
}

/*
 * Propagate values across a spanning tree starting from the closest source.
 * 
 * Return type: (bool, any, fun, fun) -> any. initial and accumulate parameter
 * type must be consistent.
 * 
 * @param source whether the current node is a source
 * @param initial initial value of the computation
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @param accumulate how to manage the value
 * @return accumulated value
 */
public def G2(source, initial, metric, density, integrand, accumulate) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			// If the node is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other node potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
//			(+ (nbr distance-integral)
//	  			(* (nbr-range)
//           			(tup (mean density (nbr density))
//            			(mean integrand (nbr integrand)))))
			])
		}
	}.get(1) // return the accumulated value
}

/**
 * Gossip a value manipulated according to f.
 * 
 * Return type: (any, fun) -> any.
 * @param value what to gossip
 * @param f how to manipulate value
 * @return the value resulting from gossip
 */
public def gossip(value, f) {
	rep(v <- value) {
		f.apply(value, hood((a, b) -> { f.apply(a, b) }, value, nbr(v)))
	}
}

/**
 * Gossip a value manipulated according to f.
 * 
 * Return type: (any, fun) -> any.
 * @param value what to gossip
 * @param f how to manipulate value
 * @return the value resulting from gossip
 */
public def Gossip(value, f) {
	G(false, value, nbrRange, (v) -> { f.apply(v, value) })
}

/**
 * Gossip ever.
 * 
 * Gossip whether any location has ever experienced a given condition.
 */
public def gossipEver(a) {
	rep(ever <- false) {
		a || anyHood(nbr(ever))		
	}
}

/**
 * Forecast obstacles along a path to the source.
 * 
 * Return type: (bool, bool) -> bool.
 * @param source whether the device is a source
 * @param obstacle whether the device is an obstacle
 * @return true if the device will encounter an obstacle within the shortest
 * path towards the closest source, false otherwise
 */ 
public def forecastObstacle(source, obstacle) {
	let obs = if(obstacle) { 1 } else { 0 };
	G(source, obs, nbrRange, (v) -> { obs + v }) > 0
//	G(source, obstacle, nbrRange, (v) -> { obstacle || v })
}

/**
 * Determine the smallest distance from the current node to the source.
 * 
 * Return type: (bool, num, fun, fun, fun) -> num.
 * @param source whether the node is a source
 * @param init distance initial value
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @param latency communication latencies between neighbors
 * @param maximum communication range
 * @return field of minimum distances from nodes to the closest source
 */
public def gradient(source, init, metric, latency, range) {
	rep(distance <- [Infinity, 0]) {
		mux(source) { 
			[init, 0]
		} else {
			let d = distance.get(0);
			let v = distance.get(1);
			mux(anyHood(addRangeWithLag(nbr(distance).get(0), metric, v, latency) <= d)) {
				let ndv = nbr(distance);
				minHood([ndv.get(0) + metric.apply(), 0])
			} else {
				let v0 = range.apply() / 2;
				[d + v0 * self.dt(), v0]
			}
		}	  
	}.get(0)
}

public def gradcast(f, init, accumulate) {
	rep(value <- [Infinity, init]) {
		minHood([nbr(f.apply()), accumulate.apply(value.get(1))]);
	}.get(1)
}

/**
 * Verify if a device is on the edge of a spatial region.
 * 
 * Return type: (any) -> bool.
 * @param condition` how to discriminate a region
 * @return true if the device is on the edge, false otherwise
 */
 public def isEdge(condition) {
 	!(allHood(nbr(condition)) || allHood(!nbr(condition)))
 }
 
/**
 * Count the number of neighbors.
 * 
 * () -> num.
 * @return number of neighbors
 */
 public def neighborhood() {
 	sumHood(nbr(1))
 }
 
/*
 * Estimate the distance from the current node to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current to its neighbors
 */
public def nbrRange() {
	self.nbrRange()
}

/*
 * Estimate the distance from the current node to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of 1s for each neighbor
 */
public def nbrRangeHop() { 
	nbr(1) //TODO no value auto-field
}

// SAMEAS == shortest path
public def descend(source, potential) {
	rep(path <- source) {
		let nextStep = minHood(nbr([potential, self.getDeviceUID()]));
		if (nextStep.size() > 1) {
			let candidates = nbr([nextStep.get(1), path]);
			source || anyHood([self.getDeviceUID(), true] == candidates)
		} else { source }
	}
}

public def rendezvous(a, b) {
	descend(a, distanceTo(b))
}

/**
 * Dynamically computes the shortest route between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. The “shortest path” 
 * is a Boolean field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 * 
 * Return type: (bool, bool) -> bool.
 * 
 */
public def shortestPath(source, destination) {
	rep(path <- false) {
		mux (source) {
			true
		} else {
			// any device on the shortest path
			anyHood(
				// check whether a neigh is on the shortest path AND the current device is in the shortest path
				nbr (path) && 
					(distanceTo(destination) == nbr( // if my distance is the same as the collected one
						minHood( // get the closest distance
							nbr(distanceTo(destination)) // get the neighbors distances from the destination
						)
					)
				)
			)
		}
	}
}

/**
 * Entry point for a computation.
 * 
 * @param source whether the device is a source
 * @param range spreading constraint
 * @param function entry point
 * @param null default value
 * @return apply f if the device is inside the spreading region, null 
 * otherwise
 */
public def vm(source, range, f, null) {
	boundSpreadingWithinRange(source, range, f, null)
}
 
/**  
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of seed devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed, 
 * effectively breaking the network up into zones of influence around key 
 * elements.
 * 
 * Return type: (bool, num) -> num.
 * 
 * @param seed whether the device is a seed
 * @param id partition id
 * @return partition of the nearest seed
 */
 public def voronoiPatitioning(seed, id) {
 	G(seed, id, nbrRange, identity)
 }
  






def dominantValue(value) {
	rep(tup <- [0, self.getDeviceUID(), value]) {
		let local = floor(1 / self.nextRandomDouble()); // no matter what the network diameter is
		let hoodmax = maxHood PlusSelf(nbr([tup.get(0) - 1, tup.get(1), tup.get(2)]));
		let leader = hoodmax.get(1) == tup.get(1);
		if (leader || local > hoodmax.get(0)) {
			[max(local, hoodmax.get(0)), self.getDeviceUID(), value]
		} else {
			hoodmax
		}
	}
	.get(2)
}

public def pldConsensus(intial, alpha, beta) {
	rep(value <- intial) {
		// regional dominant
		alpha * dominantValue(value)
		// blend incrementally with local
		+ (1 - alpha) * value
		// add laplacian differential
		+ beta * sumHood PlusSelf(nbr(value) - value)
	}
}

public def slope(d, minD, metric) {
	//TODO cosa fa la fooldHood
	hood(
		
		(x, r) -> {
			let nrange = metric.apply();
			if(nrange > 0) {
				nrange = metric.apply();
				let m = max(minD, maxHood(nrange));
				let slope = (d - x) / m;
				if(slope > r.get(0)) {
					nrange = metric.apply();
					m = max(minD, maxHood(nrange));
					[slope, x, m]
				} else { r } //????
			} else { r }
		}, 
		[-Infinity, Infinity, 0], 
		//[d, minD, 0] //ArrayTupleImpl cannot be cast to org.protelis.lang.datatype.Field
		//d // java.lang.Double cannot be cast to org.protelis.lang.datatype.Field
		nbr(d)
	)
	
}

public def flexGradient(src, epsilon, rate, range, distortion, metric) {
	rep(d <- Infinity) {
		mux(src) { 
			0
		} else {
			let minD = range * distortion;
			let slopeInfo = slope(d, minD, metric);
			let maxSlope = slopeInfo.get(0);
			let msd = slopeInfo.get(1);
			let msr = slopeInfo.get(2);
			let ct = minHood(nbr(d) + max(minD, maxHood(metric.apply())));
			mux((d > range && d > ct * 2) || cyclicTimer((d + self.dt()) * rate)) {
				ct
			} else {
				mux(maxSlope > (1 + epsilon)) {
					msd + msr * (1 + epsilon)
				} else {
					mux(maxSlope < (1 - epsilon)) {
						msd + msr * (1 - epsilon)
					} else {
						d
					}
				}
			}
		}
	}
}

public def flexGradient2(source, initial, metric, accumulate, epsilon, range, distortion) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			[0, initial]
		} else {
			// previous gradient
			let gx = distanceValue.get(0);
			env.put("gx", gx);
			let ndv = nbr(distanceValue);
			// c'_x(y,t)
			let cx1 = minHood([
				ndv.get(0) + max(distortion * range, metric.apply()),
				accumulate.apply(ndv.get(1))
			]);
			env.put("c'x", cx1);
			// s'_x
			let sx1 = maxHood([
				(ndv.get(0) - gx) / max(distortion * range, metric.apply()),
				ndv.get(0), // gy
				max(distortion * range, metric.apply()),
				ndv.get(1) // accumulated value
			]);
			env.put("s'x", sx1);
			if(max(range, 2*cx1.get(0)) < gx) {
				env.put("step", 1);
				cx1
			} else {
				if(sx1.get(0) > 1 + epsilon) {
					env.put("step", 2);
					[ sx1.get(1) + (1 + epsilon) * sx1.get(2), sx1.get(3) ] 
				} else {
					if(sx1.get(0) < 1 - epsilon) {
						env.put("step", 4);
						[ sx1.get(1) + (1 - epsilon) * sx1.get(2), sx1.get(3) ] 
					} else { env.put("step", 5); distanceValue }
				}
			}
		}
	}.get(1)
}

