module protelis:coord:spreading
import org.apache.commons.math3.util.FastMath.floor
import protelis:lang:utils
import protelis:state:time

/*
 * Add v to the field of distances from the current device to its neighbors.
 * 
 * Return type: (num) -> num.
 * @param v distance to add
 * @return field of distances from the current device to its neighbors
 */
public def addRange(v) {
	addRangeWithMetric(v, nbrRange)
}

/*
 * Add of 1 the field of distances of the current device's neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current device to its neighbors
 */
public def addRangeHop() {
	addRangeWithMetric(1, nbrRangeHop)
}

/*
 * Add v to the field of distances from the current device to its neighbors.
 * 
 * Return type: (num, fun, f) -> num.
 * @param v distance to add
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @param speed communication speed
 * @return field of distances from the current device to its neighbors
 */
public def addRangeWithLag(v, metric, speed) {
	addRangeWithMetric(v, () -> { nbrRangeLag(metric, nbrLag, speed) })
}

/*
 * Add v to the field of distances from the current device to its neighbors.
 * 
 * Return type: (num, f) -> num.
 * @param v distance to add
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @return field of distances from the current device to its neighbors
 */
public def addRangeWithMetric(v, metric) {
	v + metric.apply()
}

/**
 * Constrain the spreading of broadcast function only within a region. 
 * 
 * Return type: (bool, any, bool, any) -> any. broadcast return type and null should be
 * type consistent.
 * @param region whether the function is spreaded or not
 * @param null default value return whether f is not spreaded
 * @param source whether the current device is a source
 * @param value what to broadcast
 * @return broadcast inside the region, return null otherwise
 */
public def boundBroadcast(region, null, source, value) {
	boundSpreading(region, () -> { broadcast(source, value) }, null)
}

/**
 * Constrain the spreading of G function only within a region. 

 * Return type: (bool, bool, any, fun, fun) -> any. initial and accumulate parameter
 * type must be consistent.
 * @param region whether the function is spreaded or not
 * @param source whether the current device is a source
 * @param initial initial value of the computation
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @param accumulate how to manage the value
 * @param null default value return whether f is not spreaded
 * @return accumulated value
 */
public def boundG(region, null, source, initial, metric, accumulate) {
	boundSpreading(region, () -> { 
		G(source, initial, metric, accumulate)
	}, null)
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool, bool) -> num.
 * @param region where to compute distanceTo
 * @param source whether the device is a source
 * @return field of minimum distances to the closest source
 */
public def boundDistanceTo(region, source) {
	boundSpreading(region, () -> { distanceTo(source) }, Infinity)
}

/**
 * Constrain the spreading of f only across a region. 
 * 
 * Return type: (bool, fun, any) -> any. f return type and null should be
 * type consistent.
 * @param region whether the function is spreaded or not
 * @param f function to be spreaded
 * @param null default value return whether f is not spreaded
 * @return apply f inside the region, return null otherwise
 */
public def boundSpreading(region, f, null) {
	if (region) {
		f.apply()
	} else {
		null
	}
}

/**
 * Constrain the spreading of f only within devices close to the source. 
 * 
 * Return type: (fun, fun, any) -> any. f return type and null should be
 * type consistent.
 * @param range how to determine the range
 * @param f function to be spreaded
 * @param null default value return whether f is not spreaded
 * @return apply f inside the region, return null otherwise
 */
public def boundSpreadingWithRange(range, f, null) {
	boundSpreading(range.apply(), f, null);
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current device is a source
 * @param value what to broadcast
 * @return broadcasted value
 */
public def broadcast(source, value) {
	broadcastWithMetric(source, value, nbrRange)
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current device is a source
 * @param value what to broadcast
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @return broadcasted value
 */
public def broadcastWithMetric(source, value, metric) {
	G(source, value, metric, identity)
}

/**
 * Dynamically computes distributed routes between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. Examples 
 * of its use include long-range reliable communications, or advanced crowd 
 * steering applications in pervasive computing. The “channel” is a Boolean 
 * field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * @param source whether the device is a source
 * @param destination whether the device is a destination
 * @param obstacle whether the device is an obstacle
 * @param thr threshold for Double comparison
 * @param width how much to dilate the channel
 * @return true if the device is on the shortest path, false otherwise
 */
public def channel(source, destination, obstacle, thr, width) {
  	boundSpreading(!obstacle, () -> { 
  		let d = distanceBetween(source, destination);
  		if (d == Infinity) { false }
  		else {
  			distanceTo(distanceTo(source) + distanceTo(destination) <=  d + thr) <= width
  		}
  	}, false)
}

/**
 * Channel pattern.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * @param source whether the device is a source
 * @param destination whether the device is a destination
 * @param obstacle whether the device is an obstacle
 * @param width how much to dilate the channel
 * @return true if the device is on the shortest path, false otherwise
 */
public def channel2(source, destination, obstacle, width) {
  	boundSpreading(!obstacle, () -> { 
  		distanceTo(shortestPath(source, destination)) <= width
  	}, false)
}

/**
 * @param source whether the device is a source
 * @param range range
 * @return true if the device is closer than range to the source, false
 * otherwise
 */
public def closerThan(source, range) {
	distanceToWithMetric(source, nbrRange) < range
}

/**
 * @param source whether the device is a source
 * @param metric how to estimate the distance
 * @param range range
 * @return true if the device is closer than range to the source, false
 * otherwise
 */
public def closerThanWithMetric(source, metric, range) {
	distanceToWithMetric(source, metric) < range
}

/**
 * Splice devices into regions according to the discriminant and apply f.
 * 
 * Return type: (any, fun, any) -> any.
 * @param discriminant split regions according to this value
 * @param filter how to handle the discriminant value
 * @param function what to apply in each region
 * @param default default value
 * @return apply f
 */
public def computeMultiRegion(discriminant, filter, function, default) {
	if (filter.apply(discriminant)) {
		let res = alignedMap(
			nbr([[discriminant, default]]),
			(key, field) -> { filter.apply(key) },
			(key, field) -> { function.apply() }, 
			default
		);
		if (res == []) { default } else { res.get(0).get(1) }
	} else { default }
}

/**
 * Self-healing gradcast algorithm that reconfigures in O(diameter) time. 
 * Requires euclidean metric. The CRF-Gradient algorithm handles this problem 
 * by splitting the calculation into constraint and restoring force behaviors.
 * When constraint is dominant, the value of a device gx(t) stays fixed or 
 * decreases, set by the triangle inequality from its neighbors’ values.  When 
 * restoring force is dominant, gx(t) rises at a fixed velocity v0.
 * 
 * Return type: (bool, any, fun, fun, fun, num) -> any.
 * @param source whether the device is a source
 * @param metric how to estimate distances without lag
 * @param range communication max range
 * @return accumulated value
 */
public def crfGradient(source, metric, range) {
	// potential <- [distance, speed]
	rep (potential <- [Infinity, 0]) {
		mux (source) {
			[0, 0]
		} else {
			let ndv = nbr(potential);
			let d = ndv.get(0);
			let v = ndv.get(1);
			let dt = self.dt();
			mux (anyHood(addRangeWithLag(d, metric, v) < potential.get(0))) {
				minHood([d + metric.apply(), 0])
			} else {
				let v0 = if (dt == 0) { 1 } else { range / (dt * 12) };
				[potential.get(0) + v0 * dt, v0]				
			}
		}
	}.get(0)
}

/**
 * Dilate a spatial region.
 * 
 * Return type: (bool, num) -> bool.
 * @param region whether the device is inside the region
 * @param width how big the dilatation is
 * @return dilated region
 */
 public def dilate(region, width) {
 	dilateWithMetric(region, nbrRange, width)
 }
 
/**
 * Dilate a spatial region.
 * 
 * Return type: (bool, fun, num) -> bool.
 * @param region whether the device is inside the region
 * @param metric how to estimate the distance between devices
 * @param width how big the dilatation is
 * @return dilated region
 */
 public def dilateWithMetric(region, metric, width) {
 	distanceToWithMetric(region, metric) < width	
 }
 
/**
 * Smallest distance between source and destination devices.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current device is a source
 * @param destination whether the current device is a destination
 * @return smallest distance between source and destination devices
 */
public def distanceBetween(source, dest) { 
	distanceBetweenWithMetric(source, dest, nbrRange)
}

/**
 * Smallest distance between source and destination devices.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current device is a source
 * @param destination whether the current device is a destination
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @return smallest distance between source and destination devices
 */
public def distanceBetweenWithMetric(source, dest, metric) { 
	G(source, distanceToWithMetric(dest, metric), metric, identity)
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool) -> num.
 * @param source whether the current device is a source
 * @return distance to the closest source
 */
public def distanceTo(source) {
	distanceToWithMetric(source, nbrRange)	
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool, f) -> num.
 * @param source whether the device is a source
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @return field of minimum distances to the closest source
 */
public def distanceToWithMetric(source, metric) {
	G(source, 0, metric, (v) -> { v + metric.apply() })
}

/**
 * Used by flexGradient
 */
def slope(d, minD, metric) {
	let nrange = metric.apply();
	if (nrange > 0) {
		let ndv = nbr(d);
		let m = max(minD, maxHood(nrange));
		maxHood([(d - ndv)/m, ndv, m])
	} else { [0, d, 0] }
}

/**
 * Flex-Gradient.
 */
public def flexGradient(source, epsilon, rate, range, distortion, metric) {
	rep (d <- Infinity) {
		mux (source) { 
			0
		} else {
			let minD = range * distortion;
			let slopeInfo = slope(d, minD, metric);
			let maxSlope = slopeInfo.get(0);
			let msd = slopeInfo.get(1);
			let msr = slopeInfo.get(2);
			let ct = minHood(nbr(d) + max(minD, maxHood(metric.apply())));
			mux ((d > range && d > ct * 2) || cyclicTimer((d + self.dt()) * rate)) {
				ct
			} else {
				mux (maxSlope > (1 + epsilon)) {
					msd + msr * (1 + epsilon)
				} else {
					mux (maxSlope < (1 - epsilon)) {
						msd + msr * (1 - epsilon)
					} else {
						d
					}
				}
			}
		}
	}
}

/*
 * Propagate values across a spanning tree starting from the closest source.
 * 
 * Return type: (bool, any, fun, fun) -> any. initial and accumulate parameter
 * type must be consistent.
 * 
 * @param source whether the current device is a source
 * @param initial initial value of the computation
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @param accumulate how to manage the value
 * @return accumulated value
 */
public def G(source, initial, metric, accumulate) {
	rep (distanceValue <- [Infinity, initial]) {
		mux (source) {
			// If the device is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other device potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			// TODO do we need a default?
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
			])
		}
	}.get(1) // return the accumulated value
}

/**
 * Gossip a value manipulated according to f.
 * 
 * Return type: (any, fun) -> any.
 * @param value what to gossip
 * @param f how to manipulate value
 * @return the value resulting from gossip
 */
public def gossip(value, f) {
	rep (v <- value) {
		f.apply(value, hood((a, b) -> { f.apply(a, b) }, value, nbr(v)))
	}
}

/**
 * Gossip a value manipulated according to f.
 * 
 * Return type: (any, fun) -> any.
 * @param value what to gossip
 * @param f how to manipulate value
 * @return the value resulting from gossip
 */
public def Gossip(value, f) {
	G(false, value, nbrRange, (v) -> { f.apply(v, value) })
}

/**
 * Gossip whether the device has ever experienced a given condition.
 * 
 * Return type: (bool) -> bool.
 * @param a condition
 * @return true if the device has experienced the condition, false otherwise
 */
public def gossipEver(a) {
	rep (ever <- false) {
		a || anyHood(nbr(ever))		
	}
}

/**
 * Forecast obstacles along a path to the source.
 * 
 * Return type: (bool, bool) -> bool.
 * @param source whether the device is a source
 * @param obstacle whether the device is an obstacle
 * @return true if the device will encounter an obstacle within the shortest
 * path towards the closest source, false otherwise
 */ 
public def forecastObstacle(source, obstacle) {
	forecastObstacleWithMetric(source, obstacle, nbrRange)
}

/**
 * Forecast obstacles along a path to the source.
 * 
 * Return type: (bool, bool) -> bool.
 * @param source whether the device is a source
 * @param obstacle whether the device is an obstacle
 * @param metric how to estimate neighbors distances  
 * @return true if the device will encounter an obstacle within the shortest
 * path towards the closest source, false otherwise
 */ 
public def forecastObstacleWithMetric(source, obstacle, metric) {
	let obs = if (obstacle) { 1 } else { 0 };
	G(source, obs, metric, (v) -> { obs + v }) > 0
//	G(source, obstacle, nbrRange, (v) -> { obstacle || v })
}

/**
 * Gradcast. Accumulate and return value along the direction estimated 
 * by gradient.
 * 
 * Return type: (bool, fun, any, fun) -> any.
 * @param source whether the device is a source
 * @param gradient gradient to follow
 * @param local local value
 * @param accumulate how to accumulate local values
 * @return accumulated value
 */
public def gradcast(source, gradient, local, accumulate) {
	rep (value <- local) {
		mux (source) { 
			local
		} else {
			minHood([nbr(gradient.apply()), accumulate.apply(nbr(value))]).get(1)
		}
	}
}

/**
 * Determine the smallest distance from the current device to the source.
 * 
 * Return type: (bool, num, fun, fun, fun) -> num.
 * @param source whether the device is a source
 * @param initSource distance initial value
 * @param metric determine how to gauge the distance from to the current device
 * to its neighbors
 * @param communicationRange communication range
 * @return field of minimum distances from devices to the closest source
 */
public def gradient(source, initSource, metric, communicationRange) {
	rep (distance <- [Infinity, 0]) {
		mux (source) { 
			[initSource, 0]
		} else {
			let d = distance.get(0);
			let v = distance.get(1);
			mux (anyHood(addRangeWithLag(nbr(distance).get(0), metric, v) <= d)) {
				let ndv = nbr(distance);
				minHood([ndv.get(0) + metric.apply(), 0])
			} else {
				let v0 = communicationRange / 2;
				[d + v0 * self.dt(), v0]
			}
		}	  
	}.get(0)
}
 
/**
 * Count the number of neighbors.
 * 
 * () -> num.
 * @return number of neighbors
 */
public def neighborhood() {
 	sumHood(nbr(1))
}

/**
 * Communication latency.
 * 
 * Return type: () -> num.
 * @return field of communication latencies between this device and its
 * neighbors
 */
public def nbrLag() {
	self.nbrLag()
}

/*
 * Estimate the distance of the current device to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current device to its neighbors
 */
public def nbrRange() {
	self.nbrRange()
}

/*
 * Estimate the distance from the current device to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of 1s for each neighbor
 */
public def nbrRangeHop() { 
	1 //TODO no value auto-field
}

/*
 * Estimate the distance of the current device to its neighbors.
 * 
 * Return type: (fun, fun, num) -> num.
 * @param metric how to estimate distances
 * @param lagMetric how to estimate latencies
 * @param speed communication speed
 * @return field of distances from the current device to its neighbors
 */
public def nbrRangeLag(metric, lagMetric, speed) {
	metric.apply() + (lagMetric.apply() + self.dt()) * speed
}

// SAMEAS == shortest path
public def descend(source, potential) {
	rep (path <- source) {
		let nextStep = minHood(nbr([potential, self.getDeviceUID()]));
		if (nextStep.size() > 1) {
			let candidates = nbr([nextStep.get(1), path]);
			source || anyHood([self.getDeviceUID(), true] == candidates)
		} else { source }
	}
}

public def rendezvous(a, b) {
	descend(a, distanceTo(b))
}

/**
 * Dynamically computes the shortest route between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. The “shortest path” 
 * is a Boolean field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 * 
 * Return type: (bool, bool) -> bool.
 * 
 */
public def shortestPath(source, destination) {
	rep (path <- false) {
		mux (source) {
			true
		} else {
			// any device on the shortest path
			anyHood(
				// check whether a neigh is on the shortest path AND the current device is in the shortest path
				nbr (path) && 
					(distanceTo(destination) == nbr( // if my distance is the same as the collected one
						minHood( // get the closest distance
							nbr(distanceTo(destination)) // get the neighbors distances from the destination
						)
					)
				)
			)
		}
	}
}

/**
 * Entry point for a computation.
 *
 * Return type: (bool, num, fun, any) -> any.
 * @param source whether the device is a source
 * @param range spreading constraint
 * @param f entry point
 * @param null default value
 * @return apply f if the device is inside the spreading region, null 
 * otherwise
 */
public def vm(source, range, f, null) {
	vmWithMetric(source, nbrRange, range, f, null)
}

/**
 * Entry point for a computation.
 * 
 * Return type: (bool, num, fun, fun, any) -> any.
 * @param source whether the device is a source
 * @param range spreading constraint
 * @param metric how to estimate neighbors distances 
 * @param f entry point
 * @param null default value
 * @return apply f if the device is inside the spreading region, null 
 * otherwise
 */
public def vmWithMetric(source, metric, range, f, null) {
	boundSpreadingWithRange(() -> {
		closerThanWithMetric(source, metric, range)
	}, f, null)
}
 
/**  
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of seed devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed, 
 * effectively breaking the network up into zones of influence around key 
 * elements.
 * 
 * Return type: (bool, num) -> num.
 * 
 * @param seed whether the device is a seed
 * @param id partition id
 * @return partition of the nearest seed
 */
public def voronoiPatitioning(seed, id) {
	voronoiPatitioningWithMetric(seed, id, nbrRange)
}

/**  
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of seed devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed, 
 * effectively breaking the network up into zones of influence around key 
 * elements.
 * 
 * Return type: (bool, num, function) -> num.
 * 
 * @param seed whether the device is a seed
 * @param id partition id
 * @param metric how to estimate the distances of the neighbors
 * @return partition of the nearest seed
 */
public def voronoiPatitioningWithMetric(seed, id, metric) {
	G(seed, id, metric, identity)
}

//public def slope(d, minD, metric) {
//	//TODO cosa fa la fooldHood
//	hood(
//		
//		(x, r) -> {
//			let nrange = metric.apply();
//			if (nrange > 0) {
//				nrange = metric.apply();
//				let m = max(minD, maxHood(nrange));
//				let slope = (d - x) / m;
//				if (slope > r.get(0)) {
//					nrange = metric.apply();
//					m = max(minD, maxHood(nrange));
//					[slope, x, m]
//				} else { r } //????
//			} else { r }
//		}, 
//		[-Infinity, Infinity, 0], 
//		//[d, minD, 0] //ArrayTupleImpl cannot be cast to org.protelis.lang.datatype.Field
//		//d // java.lang.Double cannot be cast to org.protelis.lang.datatype.Field
//		nbr(d)
//	)
//	
//}

