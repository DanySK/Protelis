module protelis:coord:accumulation
import protelis:coord:spreading
import protelis:state:time
import protelis:lang:utils 

/**
 * Estimate and broadcast the average value within a spatial region.
 * 
 * @param sink 	bool, whether the device is the root of the spanning tree
 * @param local num,  local value
 * @return 		num,  average value
 */
public def average(sink, value) {
	summarize(sink, sum, value, 0) / neighborhood()
}

/**
 * Estimate the average value across a bounded spatial region.
 * 
 * @param sink 	bool, whether the device is the root of the spanning tree
 * @param local num,  local value
 * @param range num,  region range
 * @param null 	num,  default value
 * @return 		num,  average value
 */
public def boundAverage(sink, local, range, null) {
	boundSpreadingWithRange(
		() -> { closerThan(sink, range) }, 
		() -> { average(sink, local) }, 
		null
	)
}

/**
 * Aggregate a field of type T within a spanning tree built according to the maximum
 * decrease in potential. Accumulate the potential according to the reduce function.
 * 
 * @param potential	num, gradient of which gives aggregation direction
 * @param reduce 	(T, T) -> T, function
 * @param local 	T, local value 
 * @param null 		T, evaluated when the field is empty
 * @return 			T, aggregated value
 */
public def C(potential, reduce, local, null) {
	rep (v <- local) {
		reduce.apply(local,
			/*
			 * TODO: switch to accumulateHood
			 */
			hood(
			    // HoodOp
				(a, b) -> { reduce.apply(a, b) },
				// expression that will be evaluated if the field is empty
				null,
				// argument to evaluate (must return a Field)
				mux (nbr(findParent(potential, identity)) == self) { nbr(v) } else { null }
			)
		)
	}	
}

/**
 * The potential-source converges to the sum of other device values.
 * C  collects  values  over  a  spanning  tree.  Even  small  perturbations
 * can  cause  loss  or  duplication  of  values  with
 * major transient impact on its result. When the accumulation
 * operation for C is either idempotent (e.g., logical and, or)
 * or  separable  (e.g.,  summation),  this  can  be  mitigated  by
 * using all paths down the potential function rather than just
 * one. Can implement  any  other  idempotent  or  separable  function.
 * 
 * @param potential num, sum values descending this potential
 * @param local 	num, value
 * @return 			num, aggregated value
 */
public def cMultiSum(potential, local) {
	 hoodWstateful(local, sum, 0, (v) -> {  				
	 	mux (potential >= nbr(potential)) { 
 				0
		} else {
			nbr(v / sumHood(
				mux (nbr(potential) < potential) { nbr(local) } else { 0 }
			))
		} 
	})
}

//(def compute-cg (root coordinates)
//     ;; center-of-gravity = sum of coordinate / number of devices
//     (broadcast root (vmul
//                       (/ 1 (tree-aggregate root 1 0))
//                       (tree-aggregate root 
//                                       coordinates
//                                       (tup 0 0 0)))))
//    
                                   
/**
 * @param potential num, accumulate values descending this potential
 * @param 			(T, T) -> T, f how to accumulate values
 * @param local 	T, local value
 * @param default 	T, default value
 * @return 			T, accumulated value
 */
public def cMultiIdempotent(potential, f, local, default) {
	 hoodWstateful(local, f, default, (v) -> { 
	 	mux (potential < nbr(potential)) { nbr(v) } else { default }
	 })
}

/**
 * The potential-source converges to the min of other device values.
 * 
 * @param potential num, minimize values descending this potential
 * @param local 	num, value
 * @return 			num, minimum value
 */
public def cMultiMin(potential, local) {
	 cMultiIdempotent(potential, min, local, Infinity)
}

/**
 * The potential-source converges to the max of other device values.
 * 
 * @param potential num, minimize values descending this potential
 * @param local 	num, value
 * @return 			num, maximum value
 */
public def cMultiMax(potential, local) {
	 -cMultiMin(potential, -local)
}

/**
 * Devices agree on a common value.
 * 
 * @param init 	num, initial device value 
 * @param f 	(num) -> num, how to determine consensus
 * @return 		num, shared value
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Estimate the diameter of the connected component joined by the current
 * device.
 * 
 * @param source 	bool, source of the connected component
 * @return diameter num, of the connected component
 */
public def diameter(source) {
	let d = distanceTo(source);
	2 * rep (maxd <- 0) {
		max(if (d < Infinity) { d } else { 0 }, maxHood(nbr(maxd)))
	}
}

/**
 * Find the parent of the current device following the maximum decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @return 			num|T, imRoot() | noParent() | accumulate(parent)
 * @see imRoot, noParent
 */
public def findParent(potential, f) {
	findParentExtended(
		potential, 
		(device) -> { f.apply(device) }, 
		(value) -> { NaN },
		NaN
	).get(0)
}

/**
 * Find the parent of the current device following the maximum decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @param g 		(T') -> T', what to do with the value
 * @param local 	T', local value
 * @param default 	T', default value for root or non parent
 * @return 			num|[T,T'], imRoot() | noParent() | accumulate(parent)
 * @see imRoot, noParent
 */
public def findParentExtended(potential, f, g, local) {
	mux (minHood(nbr(potential)) < potential) {
		let closest = minHood(
			nbr([
				potential, 
				f.apply(self), 
				g.apply(local)
			])
		);
		if (closest.size() > 1) {  [closest.get(1), closest.get(2)] } 
		else { [noParent(), local] }
	} else { [imRoot(), local] }
}

/**
 * @return num, error finding parent
 */
public def noParent() { -1 }

/**
 * @return num, root value
 */
public def imRoot() { -2 }

/**
 * Find the parent ID of the current device following the maximum decrease in 
 * potential.
 * 
 * @param num, potential potential
 * @return num|ExecutionContext, imRoot() | noParent() | parent
 * @see imRoot, noParent
 */
public def findParentId(potential) {
	findParent(potential, (device) -> { device.getDeviceUID() })
}
 
/**
 * Laplacian consensus.
 * 
 * @param init 	  num, initial value
 * @param epsilon num, epsilon
 * @return 		  num, value agreed upon consensus
 */
public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
}

/**
 * Broadcast the value accumulated by the sink. 
 * Example: 'summarize(distanceTo(sink), sum, 1, 0)' broadcast the sum number of 
 * devices in a region.
 * 
 * @param sink 	 bool, whether the device should collect the aggregated information
 * @param reduce (T, T) -> T, how to aggregate
 * @param local  T, local value
 * @param null   T, default value
 * @return 	 	 T, aggregated value
 */
public def summarize(sink, reduce, local, null) {
	summarizeWithMetric(sink, nbrRange, reduce, local, null)
}

/**
 * Broadcast the value accumulated by the sink. 
 * 
 * @param sink 	 bool, whether the device should collect the aggregated information
 * @param metric () -> num, how to estimate distance to the other device
 * @param reduce (T, T) -> T, how to aggregate
 * @param local  T, local value
 * @param null   T, default value
 * @return 	 	 T, aggregated value
 */
public def summarizeWithMetric(sink, metric, accumulate, local, null) {
	broadcast(sink, C(distanceToWithMetric(sink, metric), accumulate, local, null))
}

/**
 * Broadcast the value accumulated by the sink. 
 * 
 * @param potential num, potential
 * @param zero 		num, value representing null potential
 * @param reduce 	(T, T) -> T, how to aggregate
 * @param local  	T, local value
 * @param null   	T, default value
 * @return 	 	 	T, aggregated value
 */
public def summarizeWithPotential(potential, zero, accumulate, local, null) {
	broadcastWithMetric(
		potential == zero, 
		C(potential, accumulate, local, null), 
		() -> { potential }
	)
}