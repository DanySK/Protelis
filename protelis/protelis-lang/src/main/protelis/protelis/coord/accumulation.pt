module protelis:coord:accumulation
import protelis:coord:spreading
import protelis:state:time
import protelis:lang:utils 

/**
 * Estimate and broadcast the average value within a spatial region.
 * 
 * @param sink 	bool, whether the device is the root of the spanning tree
 * @param local num,  local value
 * @return 		num,  average value
 */
public def average(sink, value) {
	summarize(sink, sum, value, 0) / neighborhood()
}

/**
 * Estimate the average value across a bounded spatial region.
 * 
 * @param sink 	bool, whether the device is the root of the spanning tree
 * @param local num,  local value
 * @param range num,  region range
 * @param null 	num,  default value
 * @return 		num,  average value
 */
public def boundAverage(sink, local, range, null) {
	boundSpreadingWithRange(
		() -> { closerThan(sink, range) }, 
		() -> { average(sink, local) }, 
		null
	)
}

/**
 * Aggregate a field of type T within a spanning tree built according to the maximum
 * decrease in potential. Accumulate the potential according to the reduce function.
 * 
 * @param potential	num, gradient of which gives aggregation direction
 * @param reduce 	(T, T) -> T, function
 * @param local 	T, local value 
 * @param null 		T, evaluated when the field is empty
 * @return 			T, aggregated value
 */
public def C(potential, reduce, local, null) {
	rep (v <- local) {
		reduce.apply(local,
			/*
			 * TODO: switch to accumulateHood
			 */
			hood(
			    // HoodOp
				(a, b) -> { reduce.apply(a, b) },
				// expression that will be evaluated if the field is empty
				null,
				// argument to evaluate (must return a Field)
				mux (nbr(getParent(potential, identity)) == self) { nbr(v) } else { null }
			)
		)
	}	
}

/**
 * The potential-source converges to the sum of other device values.
 * C  collects  values  over  a  spanning  tree.  Even  small  perturbations
 * can  cause  loss  or  duplication  of  values  with
 * major transient impact on its result. When the accumulation
 * operation for C is either idempotent (e.g., logical and, or)
 * or  separable  (e.g.,  summation),  this  can  be  mitigated  by
 * using all paths down the potential function rather than just
 * one. Can implement  any  other  idempotent  or  separable  function.
 * 
 * @param potential num, sum values descending this potential
 * @param local 	num, value
 * @return 			num, aggregated value
 */
public def cMultiSum(potential, local) {
	 cMultiDivisible(
	 	potential, 
	 	local, 
	 	0, 
	 	sum, 
	 	(v) -> { v }, 
	 	(v) -> { sumHood(
	 		mux (nbr(potential) < potential) { nbr(local) } else { 0 }
	 	) },
	 	(dividend, divisor) -> { dividend / divisor }
	 )
}

/**
 * @param potential	num, gradient of which gives aggregation direction
 * @param local		T, local value
 * @param reduce	(T, T) -> T, how to aggregate values
 * @param dividend	(T) -> T, dividend
 * @param divisor	(T) -> T, divisor
 * @param fraction	(T, T) -> T, how to divide dividend by the divisor
 * @param null		T, null value
 * @return 			T, aggregated value
 */
public def cMultiDivisible(potential, local, null, reduce, dividend, divisor, fraction) {
	hoodWstateful(local, reduce, null, (v) -> {  				
	 	mux (potential >= nbr(potential)) { 
 				null
		} else {
			nbr(fraction.apply(dividend.apply(v), divisor.apply(v)))
		} 
	})
}
//(def compute-cg (root coordinates)
//     ;; center-of-gravity = sum of coordinate / number of devices
//     (broadcast root (vmul
//                       (/ 1 (tree-aggregate root 1 0))
//                       (tree-aggregate root 
//                                       coordinates
//                                       (tup 0 0 0)))))
//    
                                   
/**
 * @param potential num, accumulate values descending this potential
 * @param f			(T, T) -> T, how to accumulate values
 * @param local 	T, local value
 * @param default 	T, default value
 * @return 			T, accumulated value
 */
public def cMultiIdempotent(potential, f, local, default) {
	hoodWstateful(local, f, default, (v) -> { 
	 	mux (potential < nbr(potential)) { nbr(v) } else { default }
	})
}

/**
 * The potential-source converges to the min value.
 * 
 * @param potential num, minimize values descending this potential
 * @param local 	num, value
 * @return 			num, minimum value
 */
public def cMultiMin(potential, local) {
	cMultiIdempotent(potential, min, local, Infinity)
}

/**
 * The potential-source converges to the max values.
 * 
 * @param potential num, minimize values descending this potential
 * @param local 	num, value
 * @return 			num, maximum value
 */
public def cMultiMax(potential, local) {
	 -cMultiMin(potential, -local)
}

/**
 * Devices agree on a common value.
 * 
 * @param init 	num, initial device value 
 * @param f 	(num) -> num, how to determine consensus
 * @return 		num, shared value
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Estimate the diameter of the connected component joined by the current
 * device.
 * 
 * @param source 	bool, source of the connected component
 * @return diameter num, of the connected component
 */
public def diameter(source) {
	let d = distanceTo(source);
	2 * rep (maxd <- 0) {
		max(if (d < Infinity) { d } else { 0 }, maxHood(nbr(maxd)))
	}
}

/**
 * Find the parent of the current device following the maximum decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @return 			num|T, imRoot()|noParent()|f(parent)
 * @see imRoot, noParent
 */
public def getParent(potential, f) {
	getParentExtendend(
		potential, 
		(device) -> { f.apply(device) }, 
		(value) -> { NaN },
		NaN
	).get(0)
}

/**
 * Find the parent of the current device following the maximum decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @param g 		(T') -> T', what to do with the value
 * @param local 	T', local value
 * @return 			[num|T,T'], [imRoot()|noParent()|f(parent), g(value)]
 * @see imRoot, noParent
 */
public def getParentExtendend(potential, f, g, local) {
	getParentExtended(
		potential, 
		(v) -> { minHood(v) },
		f, 
		g, 
		local, 
		local
	)
}

/**
 * Find the parents of the current device following the decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @param g 		(T') -> T', what to do with the value
 * @param local 	T', local value
 * @return 			[[num|T,T']], [[imRoot()|noParent()|f(parent), g(value)]]
 * @see imRoot, noParent
 */
public def getParents(potential, f, g, local, default) {
	getParentExtended(potential, identity, f, g, local, default)
}


/**
 * Find the parents of the current device following the decrease in 
 * potential.
 * 
 * @param potential num, potential
 * @param condition (num) -> bool, how to determine parent devices
 * @param f 		(ExecutionContext) -> T, what to do with the parent
 * @param g 		(T') -> T', what to do with the value
 * @param local 	T', local value
 * @return 			[[num|T,T']], [[imRoot()|noParent()|f(parent), g(value)]]
 * @see imRoot, noParent
 */
public def getParentExtended(potential, condition, f, g, local, default) {
	mux (condition.apply(nbr(potential)) < potential) {
		let c = condition.apply(nbr([potential, f.apply(self), g.apply(local)]));
		mux (c.size() > 1) {  [c.get(1), c.get(2)] }
		else { [noParent(), default] }
	} else { [imRoot(), default] }
}

/**
 * @return num, error finding parent
 */
public def noParent() { -1 }

/**
 * @return num, root value
 */
public def imRoot() { -2 }

/**
 * Find the parent ID of the current device following the maximum decrease in 
 * potential.
 * 
 * @param num, potential potential
 * @return num|ExecutionContext, imRoot()|noParent()|parent
 * @see imRoot, noParent
 */
public def getParentId(potential) {
	getParent(potential, (device) -> { device.getDeviceUID() })
}
 
/**
 * Laplacian consensus.
 * 
 * @param init 	  num, initial value
 * @param epsilon num, epsilon
 * @return 		  num, value agreed upon consensus
 */
public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
}

/**
 * Broadcast the value accumulated by the sink. 
 * Example: 'summarize(distanceTo(sink), sum, 1, 0)' broadcast the sum number of 
 * devices in a region.
 * 
 * @param sink 	 bool, whether the device should collect the aggregated information
 * @param reduce (T, T) -> T, how to aggregate
 * @param local  T, local value
 * @param null   T, default value
 * @return 	 	 T, aggregated value
 */
public def summarize(sink, reduce, local, null) {
	summarizeWithMetric(sink, nbrRange, reduce, local, null)
}

/**
 * Broadcast the value accumulated by the sink. 
 * 
 * @param sink 	 bool, whether the device should collect the aggregated information
 * @param metric () -> num, how to estimate distance to the other device
 * @param reduce (T, T) -> T, how to aggregate
 * @param local  T, local value
 * @param null   T, default value
 * @return 	 	 T, aggregated value
 */
public def summarizeWithMetric(sink, metric, accumulate, local, null) {
	broadcast(sink, C(distanceToWithMetric(sink, metric), accumulate, local, null))
}

/**
 * Broadcast the value accumulated by the sink. 
 * 
 * @param potential num, potential
 * @param zero 		num, value representing null potential
 * @param reduce 	(T, T) -> T, how to aggregate
 * @param local  	T, local value
 * @param null   	T, default value
 * @return 	 	 	T, aggregated value
 */
public def summarizeWithPotential(potential, zero, accumulate, local, null) {
	broadcastWithMetric(
		potential == zero, 
		C(potential, accumulate, local, null), 
		() -> { potential }
	)
}