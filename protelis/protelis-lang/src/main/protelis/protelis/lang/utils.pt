module protelis:lang:utils

/**
 * Return type: (bool, bool) -> bool.
 * @param a first condition
 * @param b second condition
 * @return true if both the conditions are true
 */
public def and(a, b) {
	a && b
}

///**
// * Build a field from a value.
// * 
// * Return type: (any) -> any.
// * @param value value to be fielded
// * @return field of the given value
// */
//public def field(v) {
//	nbr(v)
//}

/**
 * Line-of-sight detector.
 * 
 * Return type: (any) -> bool.
 * @param x value
 * @return true if there is at least a neighbor respect to x, false otherwise
 */
public def canSee(x) {
	anyHood(nbr(x))
}

///**
// * Return type: (fun) -> fun.
// * @param f function 
// * @return g(f(args))
// */
//public def composeF(f) {
//	() -> { f.apply() }
//}
//
///**
// * Return type: (any) -> fun.
// * @param a value to be composed as a function
// * @return a function which returns a
// */
//public def composeV(a) {
//	() -> { a }
//}

/**
 * @param x value to be denormalized
 * @param oldmin oldmin
 * @param oldmax oldmax
 * @param newmin newmin
 * @param newmax newmax
 * @return denormalized value
 */
public def denormalize(x, oldmin, oldmax, newmin, newmax) {
	x * (newmax - newmin) / (oldmax - oldmin) + (newmin - oldmin)
} 
 
/**
 * Return type: (num, num) -> num.
 * @param a first field
 * @param b second field
 * @return difference between two fields
 */
public def diff(a, b) {
	a - b
}

/**
 * *-hood wrapper.
 * 
 * Return type: (any, fun, any, fun) -> any.
 * @param local local value
 * @param aggregator how to reduce information
 * @param default default value in case the field returned by fieldBuilder is empty
 * @param fiedBuilder return which field should be reduced
 * @return reduced value
 */
public def hoodW(local, aggregator, default, fieldBuilder) {
	 rep (v <- local) {
 		aggregator.apply(local, 
 			hood(
 				(a, b) -> { aggregator.apply(a, b) },
 				default,
 				fieldBuilder.apply(v)
 			)
 		)
 	}
}

/**
 * Stateful *-hood wrapper.
 * 
 * Return type: (any, fun, any, fun) -> any.
 * @param local local value
 * @param aggregator how to reduce information
 * @param default default value in case the field returned by fieldBuilder is empty
 * @param fiedBuilder return which field should be reduced
 * @return reduced value
 */
public def hoodWstateful(local, aggregator, default, fieldBuilder) {
	rep (v <- local) {
		hoodW(local, aggregator, default, fieldBuilder)
	}
}

/**
 * Return type: (any) -> any
 * @param a value to be returned
 * @return the same value
 */
public def identity(a) { 
	a
}

/**
 * Verify if a device is on the edge of a spatial region.
 * 
 * Return type: (any) -> bool.
 * @param condition` how to discriminate a region
 * @return true if the device is on the edge, false otherwise
 */
 public def isEdge(condition) {
 	!(allHood(nbr(condition)) || allHood(!nbr(condition)))
 }

/**
 * Apply f to all the tuple elements satisfying the filtering condition. 
 * Default is applied otherwise.
 * 
 * Return type: (tuple, f, f, any) -> any.
 * @param tuple iterate over this tuple
 * @param filter filtering condition
 * @param f function to be applied
 * @param default default value. Its type must be consistend with f's
 * return type 
 * @return default
 */
public def iterate(tuple, filter, f, default) {
	if (tuple.size() > 0) {
		if (filter.apply(tuple.get(0))) {
			f.apply(tuple.get(0))
		} else {
			default
		};
		iterate(tuple.subTupleEnd(1), filter, f, default)
	} else {
		default
	}
}

/**
 * Return type: (num, num) -> num.
 * @param a first field
 * @param b second field
 * @return maximum between the two fields
 */
public def max(a, b) {
	if (a.compareTo(b) > 0 ) {
		a
	} else {
		b
	}
}

/**
 * Return type: (num, num) -> num.
 * @param a first field
 * @param b second field
 * @return mean of the two fields
 */
public def mean(local, field) {
	(local + field) / 2
}

/**
 * Return type: (num, num) -> num.
 * @param a first field
 * @param b second field
 * @return minimum between the two fields
 */
public def min(a, b) {
	if (a.compareTo(b) < 0 ) {
		a
	} else {
		b
	}
}

/**
 * Return type: (bool) -> bool.
 * @param a condition
 * @return negated condition
 */
public def not(a) {
	!a
}

/**
 * Return type: (bool, bool) -> bool.
 * @param a first condition
 * @param b second condition
 * @return true if one of the conditions is true
 */
public def or(a, b) {
	a || b
}

/**
 * Return type: (num, num, num) -> num.
 * @param x value
 * @param min lower bound
 * @param max upper bound
 * @return scale x with respect to the range
 */
public def range(x, min, max) {
	x * (max - min) + min
}

/**
 * Reduce a tuple according to f.
 * 
 * Return type: (tuple, fun) -> any.
 * @param tuple tuple to be reduced
 * @param f how to reduce the tuple
 * @return reduced tuple
 */
public def reduce(tuple, f) {
	if (tuple.size() <= 1) {
		tuple.get(0);
	} else {
		f.apply(tuple.get(0), reduce(tuple.subTupleEnd(1), f));
	}
}

/**
 * Return type: (num, num) -> num.
 * @param a summand
 * @param b summand
 * @return sum of two fields
 */
public def sum(a, b) {
	a + b
}

/**
 * Return type: () -> num.
 * @return 0
 */
public def zero() {
	0
}