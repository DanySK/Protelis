module protelis:lang:timereplication
import org.apache.commons.math3.util.FastMath.max
import org.apache.commons.math3.util.FastMath.pow
import org.apache.commons.math3.util.FastMath.floor
import org.apache.commons.math3.util.FastMath.min
import org.protelis.swarm.Process.*
import protelis:lang:sharedTimer

/*
 * This function should return false if the clock is out of date (namely: no node in the network is still on that clock).
 */
def isCurrent(currentClock, clock, k) {
	currentClock - clock < k
}

def isNewClock(processes, clock) {
	processes
		.map(self, process -> {process.pid()})
		.filter(self, pid -> {clock == pid})
		.isEmpty()
}

def clock(tuple) {
	tuple.get(0)
}

def emptyProcess() {
	rep(p <- newProcess(Infinity, () -> {"EMPTY"}, "EMPTY")) {
		p
	}
}

def alignedExecution(processes) {
	alignedMap(
		nbr(processes.map(self, p -> { [p.pid(), p] } )),
		(pid, pField) -> { true },
		(pid, pField) -> {
			let p = hoodPlusSelf(
				(a, b) -> {if(a.compareTo(b) < 0) {a} else {b}},
				emptyProcess(),
				pField
			);
			p.update(p.function().apply())
		},
		emptyProcess()
	).map(self, tProc -> { tProc.get(1) } );
}

public def timeReplicated(process, default, p, k) {
	let clock = sharedTimer(p, self.getDeltaTime());
	rep(processes <- []) {
		/*
		 * Add process if the clock is new
		 */
		if(isNewClock(processes, clock)) {
			processes = processes.append(newProcess(clock, process, default))
		} else {0};
		/*
		 * Align on clock, execute process
		 */
		alignedExecution(processes.filter(self, p -> {clock - p.pid() < k}))
	}
	.min(emptyProcess())
	.result();
}
