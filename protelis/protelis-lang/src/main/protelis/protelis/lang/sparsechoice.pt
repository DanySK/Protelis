module protelis:lang:sparsechoice
import protelis:lang:spreading

def breakUsingUids(uid, grain, metric) {
	// Return true if the current device is leader of the partition. Lead = current leader
	rep(lead <- uid) {
		distanceCompetition(G(uid == lead, 0, metric, (v) -> { v + metric.apply() }), lead, uid, grain, metric)
	} == uid
}

def distanceCompetition(d, lead, uid, grain, metric) {
	mux(d > grain) { 
		// Device is far. Propose its id
		uid 
	} else {
		let thr = 0.5 * grain;
		mux(d >= thr) {
			// Nearest neighbor in the second half (outer side) of the region. Do not challenge at all
			Infinity 
		} else {
			// Challenge for this partition
			minHood(
				mux(nbr(d) + metric.apply() >= thr) { 
					// Device in the second half (outer side) of the region. Do not challenge at all
					Infinity
				} else {
					// Suggest the uid with the lowest random number
					nbr(lead)
				}
			)
		}
	}	
}

/**
 * Pair a random value to the device's id
 */
def randomUid() {
	rep(v <- [self.nextRandomDouble(), self.getDeviceUID()]) {
		[v.get(0), v.get(1)]	
	}
}

/**
 * Devices compete against one another to become local leaders,
 * resulting  in  a  random  Voronoi  partition  with  a  characteristic
 * grain size.
 * 
 * Return type: (num, fun) -> bool.
 * @param grain partition dimension
 * @param distance how to gauge distance from the leader
 * @return true if the current device is the leader, false otherwise
 */
public def S(grain, metric) {
	breakUsingUids(randomUid(), grain, metric)
}

