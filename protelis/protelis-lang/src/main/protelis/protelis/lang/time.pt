module protelis:lang:time

import java.lang.Math.min
import java.lang.Math.max

import protelis:lang:core
/*
 * Timer
 * initial: initial value of the timer
 * zero: lower boundary of the timer
 * decay: timer decrease its value according to this function
 */
public def T(initial, zero, decay) {
	rep(v <- initial) { // stateful. rep is initialized only the first time the function is invoked
		min(initial, max(zero, decay.apply(v)))
	}
}


public def delayFunction(initial, decay, function) {
	if (T(initial, 0, (t) -> {t - decay}) <= 0) {
		function.apply()
	} else {
		NaN
	}
}


public def cyclicTimer(length) {
	cyclicTimerWithDecay(length, self.dt())
}

/*
 * Cyclic timer
 * length: duration of the each cycle
 * decay: decay rate
 */
public def cyclicTimerWithDecay(length, decay) {
	rep(left <- length) {
		if(left == 0) {
			length
		} else {
			T(length, 0, (t) -> {t - decay})
		}
	} == length
}

public def cyclicFunction(length, decay, function) {
	if (cyclicTimerWithDecay(length, decay)) {
		function.apply()
	} else {
		NaN
	}
}

//public def limitedMemory(value, timeout, dt) {
//	T([timeout, value], [0, false], (t) -> {[t.get(0) - dt, t.get(1)]}).get(1)
//}

/**
 * Hold `value` until a specified `timeout`. Return `false` when `T` returns 0.
 */
public def limitedMemory(value, null, timeout, dt) {
	if (T(timeout, 0, (t) -> {t - dt}) <= 0) { 
		null
	} else { 
		value
	}
}

public def timer(length) {
	timerWithDt(length, self.dt())
}

public def timerWithDt(length, dt) {
	T(length, 0, (t) -> {t - dt})
}

def recentEvent(event, timeout) {
	if(event) { 
		true
	} else { 
		timer(timeout) > 0
	}
}

public def Tfilter(value) {
	T(value, value, identity)
}