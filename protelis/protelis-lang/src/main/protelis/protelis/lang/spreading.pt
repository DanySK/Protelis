module protelis:lang:spreading
import org.apache.commons.math3.util.FastMath.floor
import protelis:lang:core
import protelis:lang:time

def GPI(source, initial, density, integrand, nbrFun) {
	if (density < 0) {
		// is this the boundary?
		NaN
	} else {
		rep(distanceIntegral <- [Infinity, initial]) {
			mux (source) {
				[0, initial]
			} else {
				let range = nbrFun.apply();
				minHood(
					nbr(distanceIntegral) + [
						range * mean(density, nbr(density)), // mean = (density + nbr(density)) / 2
						range * mean(integrand, nbr(integrand))
					]
				)
			}
		}.get(1)
	}
}

def GPIdistanceTo(source, obstacle) {
	GPI(source, 0, if(obstacle) {-1} else {1}, 1, nbrRange)
}

def GPIbroadcast(source, value) {
	GPI(source, value, 1, 0, nbrRange)
}

/*
 * Gradcast algorithm
 * source: boolean value representing whether the node is a gradient source
 * initial: initial value
 * metric: the gradient is estimated with respect to this distance function
 * accumulate: values are accumulated with respect to this function
 */
public def G(source, initial, metric, accumulate) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			// If the node is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other node potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
			])
		}
	}.get(1) // return the accumulated value
}

public def CRF(src, initial, metric, accumulate, latency, range) {
	// potential <- [distance, speed, accumulatedValue]
	rep(potential <- [Infinity, 0, initial]) {
		mux(src) {
			[0, 0, initial]
		} else {
			let ndv = nbr(potential);
			let d = ndv.get(0); // inf
			let v = ndv.get(1); // 0
			let dt = self.dt(); // 1
			let nrange = metric.apply(); // 1
			mux(anyHood((d + nrange + v * (latency.apply() + dt)) < potential.get(0))) {
				minHood([d + nrange, 0, accumulate.apply(ndv.get(2))])
			} else {
				let v0 = if(dt == 0) { 1 } else { range / (dt * 12) };
				[potential.get(0) + v0 * dt, v0, potential.get(2)]				
			}
		}
	}.get(2)
}

public def oneHopSlope(d, minD, metric) {
	hood(
		(r, x) -> {
			let nrange = metric.apply();
			if(nrange > 0) {
				nrange = metric.apply();
				let m = max(minD, nrange.fold(max));
				let slope = (d - x) / m;
				if(slope > r.get(0)) {
					nrange = metric.apply();
					m = max(minD, nrange.fold(max));
					[slope, x, m]
				} else { r } //????
			} else { r }
		}, 
		[-Infinity, Infinity, 0], 
		d
	)
}

public def flexGradient(src, epsilon, rate, range, distortion, metric) {
	rep(d <- Infinity) {
		mux(src) { 
			0
		} else {
			let minD = range * distortion;
			let slopeInfo = oneHopSlope(d, minD, metric);
			let maxSlope = slopeInfo.get(0);
			let msd = slopeInfo.get(1);
			let msr = slopeInfo.get(2);
			let ct = minHood(nbr(d) + max(minD, metric.apply().fold(max)));
			mux((d > range && d > ct * 2) || cyclicTimer((d + self.dt()) * rate)) {
				ct
			} else {
				mux(maxSlope > (1 + epsilon)) {
					msd + msr * (1 + epsilon)
				} else {
					mux(maxSlope < (1 - epsilon)) {
						msd + msr * (1 - epsilon)
					} else {
						d
					}
				}
			}
		}
	}
}

public def flexGradient2(source, initial, metric, accumulate, epsilon, range, distortion) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			[0, initial]
		} else {
			// previous gradient
			let gx = distanceValue.get(0);
			env.put("gx", gx);
			let ndv = nbr(distanceValue);
			// c'_x(y,t)
			let cx1 = minHood([
				ndv.get(0) + max(distortion * range, metric.apply()),
				accumulate.apply(ndv.get(1))
			]);
			env.put("c'x", cx1);
			// s'_x
			let sx1 = maxHood([
				(ndv.get(0) - gx) / max(distortion * range, metric.apply()),
				ndv.get(0), // gy
				max(distortion * range, metric.apply()),
				ndv.get(1) // accumulated value
			]);
			env.put("s'x", sx1);
			if(max(range, 2*cx1.get(0)) < gx) {
				env.put("step", 1);
				cx1
			} else {
				if(sx1.get(0) > 1 + epsilon) {
					env.put("step", 2);
					[ sx1.get(1) + (1 + epsilon) * sx1.get(2), sx1.get(3) ] 
				} else {
					if(sx1.get(0) < 1 - epsilon) {
						env.put("step", 4);
						[ sx1.get(1) + (1 - epsilon) * sx1.get(2), sx1.get(3) ] 
					} else { env.put("step", 5); distanceValue }
				}
			}
		}
	}.get(1)
}

/*
 * Estimate the distance from the current node to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current to its neighbors
 */
public def nbrRange() {
	self.nbrRange()
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num) -> num.
 * @param v distance to add
 * @return field of distances from the current to its neighbors
 */
public def addRange(v) {
	addRangeWithMetric(v, nbrRange)
}

/*
 * Estimate the distance from the current node to its neighbors.
 * 
 * Return type: () -> num.
 * @return field of 1s for each neighbor
 */
public def nbrRangeHop() { 1 }

/*
 * Add of 1 the field of distances of the current node's neighbors.
 * 
 * Return type: () -> num.
 * @return field of distances from the current to its neighbors
 */
public def addRangeHop() {
	addRangeWithMetric(1, nbrRangeHop)
}

/*
 * Add v to the field of distances from the current node to its neighbors.
 * 
 * Return type: (num, f) -> num.
 * @param v distance to add
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return field of distances from the current to its neighbors
 */
public def addRangeWithMetric(v, metric) {
	v + metric.apply()
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool) -> num.
 * @param source whether the current node is a source
 * @return distance to the closest source
 */
public def distanceTo(source) {
	distanceToWithMetric(source, nbrRange)	
}

/*
 * Distance from the current to the closest source.
 * 
 * Return type: (bool, f) -> num.
 * @param source whether the current node is a source
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return distance to the closest source
 */
public def distanceToWithMetric(source, metric) {
	G(source, 0, metric, (v) -> {v + metric.apply()})
}

/**
 * Smallest distance between source and destination nodes.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current node is a source
 * @param destination whether the current node is a destination
 * @return smallest distance between source and destination nodes
 */
public def distanceBetween(source, dest) { 
	distanceBetweenWithMetric(source, dest, nbrRange)
}

/**
 * Smallest distance between source and destination nodes.
 * 
 * Return type: (bool, bool) -> num
 * @param source whether the current node is a source
 * @param destination whether the current node is a destination
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return smallest distance between source and destination nodes
 */
public def distanceBetweenWithMetric(source, dest, metric) { 
	G(source, distanceToWithMetric(dest, metric), metric, identity)
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current node is a source
 * @param value what to broadcast
 * @return broadcasted value
 */
public def broadcast(source, value) {
	broadcastWithMetric(source, value, nbrRange)
}

/*
 * Broadcast value across a spanning tree starting from the source.
 * 
 * Return type: (bool, any) -> any
 * @param source whether the current node is a source
 * @param value what to broadcast
 * @param metric determine how to gauge the distance from to the current node
 * to its neighbors
 * @return broadcasted value
 */
public def broadcastWithMetric(source, value, metric) {
	G(source, value, metric, identity)
}

/**
 * Gossip.
 * 
 * f must be idempotent.
 */
public def gossip(value, f) {
	rep (v <- value) {
		f.apply(value, hood((a, b) -> { f.apply(a, b) }, value, nbr(v)))
	}
}

public def Gossip(value, f) {
	G(false, value, nbrRange, (v) -> { f.apply(v, value) })
}

/**
 * Gossip ever.
 * 
 * Gossip whether any location has ever experienced a given condition.
 */
public def gossipEver(a) {
	rep (ever <- false) {
		a || anyHood (nbr (ever))		
	}
}

/**
 * Constrain the spreading of the 'f'.
 */
public def boundSpreading(region, f, null) {
	if (region) {
		f.apply()
	} else {
		null
	}
}

/**
 * Constrain the spreading of the 'f' within devices closer than 'meter' to the source.
 */
public def constrainSpreading(source, meter, f, null) {
	if (distanceTo(source) < meter) {
		f.apply()
	} else {
		null
	}
}

/**
 * 
 */
public def vm(source, meter, f) {
	constrainSpreading(source, meter, f, zero)
}

/**
 * Distance to devices where "source" is `true`, while avoiding devices where "obstacle" is `true`
 */
public def distanceToWithObstacle(source, obstacle) {
	if (obstacle) { Infinity }
	else { distanceTo(source) }
}

/**  
 * Voronoi partitioning. 
 * 
 * Return type: (bool, num) -> num.
 * 
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of “seed” devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed (by some 
 * not necessarily Euclidean metric), effectively breaking the network up into
 *  “zones of influence” around key elements.
 */
 public def voronoiPatitioning(seed, id) {
 	G(seed, id, nbrRange, identity)
 }
 
  
 /**
  * Channel pattern.
  * 
  * Return type: (bool, bool, bool, num) -> num.
  * 
  * Dynamically computes distributed routes between regions of a network, and 
  * dynamically adapts to shape and changes of the network topology. Examples 
  * of its use include long-range reliable communications, or advanced crowd 
  * steering applications in pervasive computing. The “channel” is a Boolean 
  * field that is true for devices near the shortest route from a given 
  * (distributed) source to a (distributed) destination.
  */
public def channel(source, destination, obstacle, thr, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		let d = distanceBetween(source, destination);
  		if (d == Infinity) { false }
  		else {
  			distanceTo(distanceTo(source) + distanceTo(destination) <=  d + thr) <= width
  		}
  	} 
}



// == shortest path
public def descend(source, potential) {
	rep(path <- source) {
		let nextStep = minHood(nbr([potential, self.getDeviceUID()]));
		if (nextStep.size() > 1) {
			let candidates = nbr([nextStep.get(1), path]);
			source || anyHood([self.getDeviceUID(), true] == candidates)
		} else { source }
	}
}

public def rendezvous(a, b) {
	descend(a, distanceTo(b))
}


/**
 * Dynamically computes the shortest route between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. The “shortest path” 
 * is a Boolean field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 * 
 * Return type: (bool, bool) -> bool.
 * 
 */
public def shortestPath(source, destination) {
	rep (path <- false) {
		mux (source) {
			true
		} else {
			// any device on the shortest path
			anyHood(
				// check whether a neigh is on the shortest path AND the current device is in the shortest path
				nbr (path) && 
					(distanceTo(destination) == nbr( // if my distance is the same as the collected one
						minHood( // get the closest distance
							nbr(distanceTo(destination)) // get the neighbors distances from the destination
						)
					)
				)
			)
		}
	}
}

/**
 * Channel pattern.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * 
 * Channel pattern which relies on 'shortestPath' function.
 */
public def channel2(source, destination, obstacle, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		distanceTo(shortestPath(source, destination)) <= width
  	} 
}

/**
 * Consensus.
 * 
 * Return type: (num, f) -> num
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Laplacian consensus.
 * 
 * Return type: (num, num) -> num.
 */
 public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
 }
 
/**
 * Forecast obstacles along a path to the source.
 * 
 * Return type: (bool, bool) -> bool.
 */ 
public def forecastObstacle(source, obstacle) {
	G(source, obstacle, nbrRange, (v) -> { obstacle || v })
}

def dominantValue(value) {
	rep (tup <- [0, self.getDeviceUID(), value]) {
		let local = floor(1 / self.nextRandomDouble()); // no matter what the network diameter is
		let hoodmax = maxHood PlusSelf(nbr([tup.get(0) - 1, tup.get(1), tup.get(2)]));
		let leader = hoodmax.get(1) == tup.get(1);
		if (leader || local > hoodmax.get(0)) {
			[max(local, hoodmax.get(0)), self.getDeviceUID(), value]
		} else {
			hoodmax
		}
	}
	.get(2)
}

public def pldConsensus(intial, alpha, beta) {
	rep (value <- intial) {
		// regional dominant
		alpha * dominantValue(value)
		// blend incrementally with local
		+ (1 - alpha) * value
		// add laplacian differential
		+ beta * sumHood PlusSelf(nbr(value) - value)
	}
}


