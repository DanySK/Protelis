module protelis:lang:spreading
import org.apache.commons.math3.util.FastMath.floor
import protelis:lang:core

def GPI(source, initial, density, integrand, nbrFun) {
	if (density < 0) {
		NaN
	} else {
		rep(distanceIntegral <- [Infinity, initial]) {
			mux (source) {
				[0, initial]
			} else {
				let range = nbrFun.apply();
				minHood(
					nbr(distanceIntegral) + [
						range * mean(density, nbr(density)),
						range * mean(integrand, nbr(integrand))
					]
				)
			}
		}.get(1)
	}
}

def GPIdistanceTo(source) {
	GPI(source, 0, if(env.has("obstacle")) {-1} else {1}, 1, nbrRange)
}

def GPIbroadcast(source, value) {
	GPI(source, value, 1, 0, nbrRange)
}

/*
 * Gradcast algorithm
 * source: boolean value representing whether the node is a gradient source
 * initial: initial value
 * metric: the gradient is estimated with respect to this distance function
 * accumulate: values are accumulated with respect to this function
 */
public def G(source, initial, metric, accumulate) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			// If the node is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other node potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
			])
		}
	}.get(1) // return the accumulated value
}

public def CRFgradient(source, initial, metric, accumulate, speed, dt, latency) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			[0, initial]
		} else {
			// previous gradient
			let gx = distanceValue.get(0);
			// apply triangle inequality
			let ndv = nbr(distanceValue);
			// c_x(y,t)
			let cx = [
				ndv.get(0) + metric.apply(),
				accumulate.apply(ndv.get(1))
			]; 
			// c'_x(y,t)
			let cx1 = [cx.get(0) 
				+ speed.apply() // speed
				* (dt.apply() + latency.apply()), 
				cx.get(1)
			];
			if(sumHood(if(cx1.get(0) + metric.apply() < gx) { 1 } else { 0 }) > 0) {
				minHood(cx)
			} else {
				[gx + speed.apply() * dt.apply(), distanceValue.get(1)]
			}
		}
	}.get(1)
}

public def flexGradient(source, initial, metric, accumulate, epsilon, range, distortion) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			[0, initial]
		} else {
			// previous gradient
			let gx = distanceValue.get(0);
			let ndv = nbr(distanceValue);
			// c'_x(y,t)
			let cx1 = minHood([
				ndv.get(0) + max(distortion * range, metric.apply()),
				accumulate.apply(ndv.get(1))
			]);
			// s'_x
			let sx1 = maxHood([
				(ndv.get(0) - gx) / max(distortion * range, metric.apply()),
				ndv.get(0), // gy
				max(distortion * range, metric.apply()),
				ndv.get(1) // accumulated value
			]);
			if(max(range, 2*cx1.get(0)) < gx) {
				cx1
			} else {
				if(sx1.get(0) > 1 + epsilon) {
					[ sx1.get(1) + (1 + epsilon) * sx1.get(2), sx1.get(3) ] 
				} else {
					if(sx1.get(0) < 1 - epsilon) {
						[ sx1.get(1) + (1 - epsilon) * sx1.get(2), sx1.get(3) ] 
					} else { distanceValue }
				}
			}
		}
	}.get(1)
}

/*
 * Field of distances between the current and the other nodes
 */
public def nbrRange() {
	self.nbrRange()
}

public def addRange(v) {
	v + nbrRange()
}

public def nbrRangeHop() { 1 }


/*
 * Distance between the current and the source nodes 
 */
public def distanceTo(source) {
	distanceToWithMetric(source, nbrRange)	
}

/*
 * Shortest distance between the current and the nearest source node
 */
public def distanceToWithMetric(source, metric) {
	// v: other node distances from the source
	// v + nbrRange(): 
	//   other node distances from the source + distance of the current node from the formers
	G(source, 0, metric, (v) -> {v + metric.apply()})
}

/**
 * Shortest path between source and destionation nodes.
 * 
 * (bool, bool) -> num
 */
public def distanceBetween(source, dest) { 
	distanceBetweenWithMetric(source, dest, nbrRange)
}

// distance of the source from the destination
public def distanceBetweenWithMetric(source, dest, metric) { 
	G(source, distanceToWithMetric(dest, metric), metric, identity)
}

/*
 * Broadcast a given value from a source within a spanning tree
 */
public def broadcast(source, value) {
	G(source, value, nbrRange, v -> {v})
}

/**
 * Gossip.
 * 
 * f must be idempotent.
 */
public def gossip(value, f) {
	rep (v <- value) {
		f.apply(value, hood((a, b) -> { f.apply(a, b) }, value, nbr(v)))
	}
}

public def Gossip(value, f) {
	G(false, value, nbrRange, (v) -> { f.apply(v, value) })
}

/**
 * Gossip ever.
 * 
 * Gossip whether any location has ever experienced a given condition.
 */
public def gossipEver(a) {
	rep (ever <- false) {
		a || anyHood (nbr (ever))		
	}
}

/**
 * Constrain the spreading of the 'f'.
 */
public def boundSpreading(region, f, null) {
	if (region) {
		f.apply()
	} else {
		null
	}
}

/**
 * Constrain the spreading of the 'f' within devices closer than 'meter' to the source.
 */
public def constrainSpreading(source, meter, f, null) {
	if (distanceTo(source) < meter) {
		f.apply()
	} else {
		null
	}
}

/**
 * Distance to devices where "source" is `true`, while avoiding devices where "obstacle" is `true`
 */
public def distanceToWithObstacle(source, obstacle) {
	if (obstacle) { Infinity }
	else { distanceTo(source) }
}

/**  
 * Voronoi partitioning. 
 * 
 * Return type: (bool, num) -> num.
 * 
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of “seed” devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed (by some 
 * not necessarily Euclidean metric), effectively breaking the network up into
 *  “zones of influence” around key elements.
 */
 public def voronoiPatitioning(seed, id) {
 	G(seed, id, nbrRange, identity)
 }
 
  
 /**
  * Channel pattern.
  * 
  * Return type: (bool, bool, bool, num) -> num.
  * 
  * Dynamically computes distributed routes between regions of a network, and 
  * dynamically adapts to shape and changes of the network topology. Examples 
  * of its use include long-range reliable communications, or advanced crowd 
  * steering applications in pervasive computing. The “channel” is a Boolean 
  * field that is true for devices near the shortest route from a given 
  * (distributed) source to a (distributed) destination.
  */
public def channel(source, destination, obstacle, thr, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		let d = distanceBetween(source, destination);
  		if (d == Infinity) { false }
  		else {
  			distanceTo(distanceTo(source) + distanceTo(destination) <=  d + thr) <= width
  		}
  	} 
}

/**
 * Shortest path.
 * 
 * Return type: (bool, bool) -> bool.
 * 
 * Dynamically computes the shortest route between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. The “shortest path” 
 * is a Boolean field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 */
public def shortestPath(source, destination) {
	rep (path <- false) {
		mux (source) {
			true
		} else {
			// any device on the shortest path
			anyHood(
				// check whether a neigh is on the shortest path AND the current device is in the shortest path
				nbr (path) && 
					(distanceTo(destination) == nbr( // if my distance is the same as the collected one
						minHood( // get the closest distance
							nbr(distanceTo(destination)) // get the neighbors distances from the destination
						)
					)
				)
			)
		}
	}
}

/**
 * Channel pattern.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * 
 * Channel pattern which relies on 'shortestPath' function.
 */
public def channel2(source, destination, obstacle, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		distanceTo(shortestPath(source, destination)) <= width
  	} 
}

/**
 * Consensus.
 * 
 * Return type: (num, f) -> num
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Laplacian consensus.
 * 
 * Return type: (num, num) -> num.
 */
 public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
 }
 
/**
 * Forecast obstacles along a path to the source.
 * 
 * Return type: (bool, bool) -> bool.
 */ 
public def forecastObstacle(source, obstacle) {
	G(source, obstacle, nbrRange, (v) -> { obstacle || v })
}

def dominantValue(value) {
	rep (tup <- [0, self.getDeviceUID(), value]) {
		let local = floor(1 / self.nextRandomDouble());
		let hoodmax = maxHood PlusSelf(nbr([tup.get(0) - 1, tup.get(1), tup.get(2)]));
		let leader = hoodmax.get(1) == tup.get(1);
		if (leader || local > hoodmax.get(0)) {
			[max(local, hoodmax.get(0)), self.getDeviceUID(), value]
		} else {
			hoodmax
		}
	}
	.get(2)
}

public def pldConsensus(intial, alpha, beta) {
	rep (value <- intial) {
		// regional dominant
		alpha * dominantValue(value)
		// blend incrementally with local
		+ (1 - alpha) * value
		// add laplacian differential
		+ beta * sumHood PlusSelf(nbr(value) - value)
	}
}


