module protelis:lang:convergecast
import protelis:lang:spreading
import protelis:lang:time
import protelis:lang:core 

/*
 * Find the parent node following the maximum decrease in potential
 */
def findParent(potential) {
	mux(minHood(nbr(potential)) < potential) {
        // If the minimum-received potential is less then the potential of this node...
		let closest = minHood(nbr([potential, self]));
		if(closest.size() > 1) {
		    // ... return the node representing such potential (if exists)
			closest.get(1)
		} else {
			-1
		}
	} else {
		NaN
	}
}

/*
 * Concentrate a potential estimated according to the given HoodOp function
 * potential: feature with respect to the HoodOp is evaluated
 * accumulate: HoodOp to apply. all, any, max, min, sum, union, ...
 * local: local value of the feature
 * null: expression that will be evaluated if the field is empty
 */
 
 // solo sorgenti puntiformi
public def C(potential, accumulate, local, null) {
	rep(v <- local) {
		accumulate.apply(local,
			/*
			 * TODO: switch to accumulateHood
			 */
			hood(
			    // HoodOp
				(a, b) -> {accumulate.apply(a, b)},
				// expression that will be evaluated if the field is empty
				null,
				// argument to evaluate (must return a Field)
				mux(nbr(findParent(potential)) == self) { nbr(v) } else { null }
			)
		)
	}	
}

/**
 * Summarize.
 * 
 * Return type: (bool, fun, num, num) -> num.
 * 
 * Broadcast the value accumulated by the source. Example: 
 * 'summarize(distanceTo(sink), sum, 1, 0)' broadcast the sum number of 
 * devices in a region.
 */
public def summarize (sink, accumulate, local, null) {
	broadcast(sink, C(distanceTo(sink), accumulate, local, null))
}

/**
 * Estimate and broadcast the average value within a spatial region.
 * 
 * Return type: (bool, num) -> num.
 * @param sink whether the device is the root of the spanning tree
 * @param local local value
 * @return average value
 */
public def average(sink, value) {
	summarize(sink, sum, value, 0) + neighborhood()
}

/**
 * Gossip implemented with C.
 */
public def Cossip(sink, value, f) {
	summarize(sink, f, value, value)	
}

public def opinionFeedback(acts, feedback) {
	Tfilter(C(G(acts, 0, nbrRange, addRange), (a,b) -> { a + b }, feedback, 0))
}

/**
 * Estimate the average value across a bounded spatial region.
 * 
 * Return type: (bool, num) -> num.
 * @param sink whether the device is the root of the spanning tree
 * @param local local value
 * @param range region range
 * @param null default value
 * @return average value
 */
public def boundAverage(sink, local, range, null) {
	boundSpreadingWithinRange(sink, () -> {
		average(sink, local)
	}, range, null)
}

/**
 * The source device converge to the sum of other device values.
 * C  collects  values  over  a  spanning  tree.  Even  small  perturbations
 * can  cause  loss  or  duplication  of  values  with
 * major transient impact on its result. When the accumulation
 * operation for C is either idempotent (e.g., logical and, or)
 * or  separable  (e.g.,  summation),  this  can  be  mitigated  by
 * using all paths down the potential function rather than just
 * one. Can implement  any  other  idempotent  or  separable  function.
 * 
 * Return type: (num, num) -> num.
 * @param potential sum values descending this potential
 * @param local value
 * @return aggregated value
 */
public def Cmultisum(potential, local) {
 	rep(v <- local) {
 		local + 
 			sumHood(
 				mux(potential >= nbr(potential)) { 
	 				0
	 			} else {
	 				nbr(v / sumHood(mux(nbr(potential) < potential) {nbr(local)} else {0}))
	 			}
 			)
 	}
}

/**
 * Devices agree on a common value.
 * 
 * Return type: (num, f) -> num.
 * @param init initial device value 
 * @param f how to determine consensus
 * @return shared value
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		// val + f.apply(sumHood PlusSelf(nbr(val) - val))
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Laplacian consensus.
 * 
 * Return type: (num, num) -> num.
 */
 public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
 }
 