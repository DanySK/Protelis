module protelis:lang:convergecast
import protelis:lang:spreading
import protelis:lang:time
import protelis:lang:core 

/*
 * Find the parent node following the maximum decrease in potential
 */
def findParent(potential) {
	mux(minHood(nbr(potential)) < potential) {
        // If the minimum-received potential is less then the potential of this node...
		let closest = minHood(nbr([potential, self]));
		if(closest.size() > 1) {
		    // ... return the node representing such potential (if exists)
			closest.get(1)
		} else {
			-1
		}
	} else {
		NaN
	}
}

/*
 * Concentrate a potential estimated according to the given HoodOp function
 * potential: feature with respect to the HoodOp is evaluated
 * accumulate: HoodOp to apply. all, any, max, min, sum, union, ...
 * local: local value of the feature
 * null: expression that will be evaluated if the field is empty
 */
 
 // solo sorgenti puntiformi
public def C(potential, accumulate, local, null) {
	rep(v <- local) {
		accumulate.apply(local,
			/*
			 * TODO: switch to accumulateHood
			 */
			hood(
			    // HoodOp
				(a, b) -> {accumulate.apply(a, b)},
				// expression that will be evaluated if the field is empty
				null,
				// argument to evaluate (must return a Field)
				mux(nbr(findParent(potential)) == self) { nbr(v) } else { null }
			)
		)
	}	
}

/**
 * Summarize.
 * 
 * Return type: (bool, f, num, num) -> num.
 * 
 * Broadcast the value accumulated by the source. Example: 
 * 'summarize(distanceTo(sink), sum, 1, 0)' broadcast the sum number of 
 * devices in a region.
 */
public def summarize (sink, accumulate, local, null) {
	broadcast(sink, C(distanceTo(sink), accumulate, local, null))
}

/**
 * Average.
 * 
 * Return type: (bool, num) -> num.
 * 
 * Broadcast the average value.
 */
public def average(sink, value) {
	summarize(sink, sum, value, 0) + summarize(sink, sum, 1, 0)
}

/**
 * Gossip implemented with C.
 */
public def Cossip(sink, value, f) {
	summarize(sink, f, value, value)	
}

public def opinionFeedback(acts, feedback) {
	Tfilter(C(G(acts, 0, nbrRange, addRange), (a,b) -> { a + b }, feedback, 0))
}

/**
 * Cmultisum.
 * 
 * Return type: (num, any) -> any.
 * 
 * C  collects  values  over  a  spanning  tree;  even  small  perturbations
 * can  cause  loss  or  duplication  of  values  with
 * major transient impact on its result. When the accumulation
 * operation for C is either idempotent (e.g., logical and, or)
 * or  separable  (e.g.,  summation),  this  can  be  mitigated  by
 * using all paths down the potential function rather than just
 * one. Can implement  any  other  idempotent  or  separable  function.
 */
public def Cmultisum(potential, local) {
//	NaN
 	rep(v <- local) {
 		local + 
 			sumHood(
 				mux(potential >= nbr(potential)) { 
	 				0
	 			} else {
	 				nbr(v / sumHood(mux(nbr(potential) < potential) {1} else {0}))
	 			}
 			)
 	}
}