module protelis:lang:spreading

/*
 * Gradcast algorithm
 * source: boolean value representing whether the node is a gradient source
 * initial: initial value
 * metric: the gradient is estimated with respect to this distance function
 * accumulate: values are accumulated with respect to this function
 */
public def G(source, initial, metric, accumulate) {
	rep(distanceValue <- [Infinity, initial]) {
		mux(source) {
			// If the node is a source then G return a 0 potential
			// and the initial value
			[0, initial]
		} else {
			// The other node potentials are requested
			let ndv = nbr(distanceValue);
			// G returns the value related to the minimum potential
			minHood([
				// potential estimation
				ndv.get(0) + metric.apply(),
				// values estimation
				accumulate.apply(ndv.get(1))
			])
		}
	}.get(1) // return the accumulated value
}

/*
 * Field of distances between the current and the other nodes
 */
public def nbrRange() {
	self.nbrRange()
}

public def addRange(v) {
	v + nbrRange()
}

public def nbrRangeHop() { 1 }


/*
 * Distance between the current and the source nodes 
 */
public def distanceTo(source) {
	distanceTo2(source, nbrRange)	
}

/*
 * Shortest distance between the current and the nearest source node
 */
public def distanceTo2(source, metric) {
	// v: other node distances from the source
	// v + nbrRange(): 
	//   other node distances from the source + distance of the current node from the formers
	G(source, 0, nbrRange, (v) -> {v + metric.apply()})
}

/**
 * Shortest path between source and destionation nodes.
 * 
 * (bool, bool) -> num
 */
public def distance(source, dest) { 
	distance2(source, dest, nbrRange)
}

// distance of the source from the destination
public def distance2(source, dest, metric) { 
    rep (distanceValue <- [Infinity, Infinity]) { //;; computing a field of pairs (distance,value)
        mux (source) { 
            [ 0, distanceTo2(dest, metric) ]
        } else { 
            //;; propagating as a gradient, using for first component of the pair
            minHood ([nbr(distanceValue).get(0) + metric.apply(), nbr (distanceValue).get(1)])
        }
    }.get(1) //;; returning the second component of the pair
}

/*
 * Broadcast a given value from a source within a spanning tree
 */
public def broadcast(source, value) {
	G(source, value, nbrRange, v -> {v})
}

/**
 * "gossip" algorithm that computes whether any location has ever experienced a given condition
 */
public def gossipEver(a) {
	rep (ever <- false) {
		a || anyHood (nbr (ever))		
	}
}

/**
 * Constrain the spreading of the 'f'.
 */
public def boundSpreading(region, f, null) {
	if (region) {
		f.apply()
	} else {
		null
	}
}

/**
 * Distance to devices where "source" is `true`, while avoiding devices where "obstacle" is `true`
 */
public def distanceTo_avoiding_obstacle(source, obstacle) {
	if (obstacle) { Infinity }
	else { distanceTo(source) }
}

/**  
 * Voronoi partitioning. 
 * 
 * Return type: (bool, num) -> num.
 * 
 * Computing a Voronoi partition is an operation that is frequently useful in 
 * distributed systems. Given an initial set of “seed” devices, a Voronoi 
 * partition assigns each device to the partition of the nearest seed (by some 
 * not necessarily Euclidean metric), effectively breaking the network up into
 *  “zones of influence” around key elements.
 */
 public def voronoiPatitioning(seed, id) {
 	rep (partition <- [Infinity, 0]) {
 		mux (seed) {
 			[0, id]
 		} else {
 			minHood (nbr ([distanceTo(seed), partition.get(1)]))
 		}
 	}.get(1)
 }
 
  
 /**
  * Channel pattern.
  * 
  * Return type: (bool, bool, bool, num) -> num.
  * 
  * Dynamically computes distributed routes between regions of a network, and 
  * dynamically adapts to shape and changes of the network topology. Examples 
  * of its use include long-range reliable communications, or advanced crowd 
  * steering applications in pervasive computing. The “channel” is a Boolean 
  * field that is true for devices near the shortest route from a given 
  * (distributed) source to a (distributed) destination.
  */
public def channel(source, destination, obstacle, thr, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		let d = distance(source, destination);
  		if (d == Infinity) { false }
  		else {
  			distanceTo(distanceTo(source) + distanceTo(destination) <=  d + thr) <= width
  		}
  	} 
}

/**
 * Shortest path.
 * 
 * Return type: (bool, bool) -> bool.
 * 
 * Dynamically computes the shortest route between regions of a network, and 
 * dynamically adapts to shape and changes of the network topology. The “shortest path” 
 * is a Boolean field that is true for devices near the shortest route from a given 
 * (distributed) source to a (distributed) destination.
 */
public def shortestPath(source, destination) {
	rep (path <- false) {
		mux (source) {
			true
		} else {
			// any device on the shortest path
			anyHood(
				// check whether a neigh is on the shortest path AND the current device is in the shortest path
				nbr (path) && 
					(distanceTo(destination) == nbr( // if my distance is the same as the collected one
						minHood( // get the closest distance
							nbr(distanceTo(destination)) // get the neighbors distances from the destination
						)
					)
				)
			)
		}
	}
}

/**
 * Channel pattern.
 * 
 * Return type: (bool, bool, bool, num) -> num.
 * 
 * Channel pattern which relies on 'shortestPath' function.
 */
public def channel2(source, destination, obstacle, width) {
  	if (obstacle) { 
  		false
  	} else { 
  		distanceTo(shortestPath(source, destination)) <= width
  	} 
}

/**
 * Consensus.
 * 
 * Return type: (num, f) -> num
 */
public def consensus(init, f) {
 	rep (val <- init) {
 		val + f.apply(sumHood(nbr(val) - val))
 	}	
} 

/**
 * Laplacian consensus.
 * 
 * Return type: (num, num) -> num.
 */
 public def laplacianConsensus(init, epsilon) {
 	consensus(init, (v) -> {epsilon * v})
 }